{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docker Swarm KhulnaSoft","text":""},{"location":"#deprecation-warning","title":"Deprecation Warning \ud83d\udea8","text":"<p>This website is deprecated.</p> <p>It's kept around mainly for historical reasons.</p> <p>See Docker Swarm Mode or Kubernetes for more information.</p> <p>If you want to see alternative resources, you could check the awesome-swarm list for more resources about Docker Swarm Mode. \ud83e\udd13</p>"},{"location":"#why","title":"Why?","text":"<p>Docker is a great tool (the \"de facto\" standard) to build Linux containers.</p> <p>Docker Compose is great to develop locally with Docker, in a replicable way.</p> <p>Docker Swarm Mode is great to deploy your application stacks to production, in a distributed cluster, using the same files used by Docker Compose locally.</p> <p>So, with Docker Swarm Mode you have:</p> <ul> <li>Replicability, use the same files as when developing locally.</li> <li>Simplicity and speed for development and deployment.</li> <li>Robustness and security, with fault-tolerant clusters.</li> </ul>"},{"location":"#docker-swarm-mode","title":"Docker Swarm mode","text":"<p>If you have Docker installed, you already have Docker Swarm, it's integrated into Docker.</p> <p>You don't have to install anything else.</p>"},{"location":"#note","title":"Note","text":"<p>Whenever you read here \"Docker Swarm\" we are actually talking about \"Docker Swarm mode\".</p> <p>Not the deprecated product called \"Docker Swarm\".</p>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Some of the main alternatives are:</p> <ul> <li>Kubernetes.</li> <li>Mesos.</li> </ul> <p>To use any of them you need to learn a huge new set of concepts, configurations, files, commands, etc.</p>"},{"location":"#about-docker-swarm-mode","title":"About Docker Swarm mode","text":"<p>Docker Swarm mode is comparable to them.</p> <p>But it, with all the ideas described here, is what I would recommend for teams of less than 200 developers, or clusters of less than 1000 machines.</p> <p>This includes small / medium size organizations (like when you are not Google or Amazon), startups, one-man projects, and \"hobby\" projects.</p> <p>Try it.</p> <p>Set up a distributed cluster ready for production.</p> <p>...In about 20 minutes.</p> <p>If it doesn't work for you, then you can go for Kubernetes, Mesos or any other.</p> <p>Those are great tools. But learning them might take weeks. So, the 20 minutes spent here are not much (and up to here you already spent 3 minutes).</p>"},{"location":"#single-server","title":"Single server","text":"<p>With Docker Swarm mode you can start with a \"cluster\" of a single server.</p> <p>You can set it up, deploy your applications and do everything on a $5 USD/month server.</p> <p>And then, when the time to grow comes, you can add more servers to the cluster.</p> <p>With a one-line command.</p> <p>And you can create your applications to be ready for massive scale from the beginning, starting from a single small server.</p>"},{"location":"#about-docker-swarm-khulnasoft","title":"About Docker Swarm KhulnaSoft","text":"<p>This is not associated with Docker or any of the tools suggested here.</p> <p>It's mainly a set of ideas, documentation and tools to use existing open source products efficiently together.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>To know some Linux.</li> <li>To know some Docker.</li> </ul>"},{"location":"#install-and-set-up","title":"Install and set up","text":""},{"location":"#install-a-new-linux-server-with-docker","title":"Install a new Linux server with Docker","text":"<ul> <li>Create a new remote VPS (\"virtual private server\").</li> <li>Deploy the latest Ubuntu LTS (\"long term support\") version. At the time of this writing it's <code>Ubuntu 18.04</code>.</li> <li>Connect to it via SSH, e.g.:</li> </ul> <pre><code>ssh root@192.0.2.175\n</code></pre> <ul> <li>Define a server name using a subdomain of a domain you own, for example <code>dog.example.com</code>.</li> <li>Make sure the subdomain DNS records point to your VPS's IP address.</li> <li>Create a temporal environment variable with the name of the host to be used later, e.g.:</li> </ul> <pre><code>export USE_HOSTNAME=dog.example.com\n</code></pre> <ul> <li>Set up the server <code>hostname</code>:</li> </ul> <pre><code># Set up the server hostname\necho $USE_HOSTNAME &gt; /etc/hostname\nhostname -F /etc/hostname\n</code></pre> <p>Note: If you are not a <code>root</code> user, you might need to add <code>sudo</code> to these commands. The shell will tell you when you don't have enough permissions. Note that <code>sudo</code> does not preserve environment variables by default, but this can be enabled via the <code>-E</code> flag.</p> <ul> <li>Update packages:</li> </ul> <pre><code># Install the latest updates\napt-get update\napt-get upgrade -y\n</code></pre> <ul> <li>Install Docker following the official guide...</li> <li>...or alternatively, run the official convenience script:</li> </ul> <pre><code># Download Docker\ncurl -fsSL get.docker.com -o get-docker.sh\n# Install Docker using the stable channel (instead of the default \"edge\")\nCHANNEL=stable sh get-docker.sh\n# Remove Docker install script\nrm get-docker.sh\n</code></pre> <ul> <li>If you are setting up multiple nodes (servers/VPSs), repeat these steps for each one.<ul> <li>Make sure you use a different domain/subdomain for each node.</li> </ul> </li> </ul>"},{"location":"#set-up-swarm-mode","title":"Set up swarm mode","text":"<p>In Docker Swarm Mode you have one or more \"manager\" nodes and one or more \"worker\" nodes (that can be the same manager nodes).</p> <p>The first step is to configure one (or more) manager nodes.</p> <ul> <li>On the main manager node, run:</li> </ul> <pre><code>docker swarm init\n</code></pre> <p>Note: if you see an error like:</p> <pre><code>Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on interface eth0 (198.51.100.48 and 10.19.0.5) - specify one with --advertise-addr\n</code></pre> <p>...select the public IP (e.g. <code>198.51.100.48</code> in this example), and run the command again with <code>--advertise-addr</code>, e.g.:</p> <pre><code>docker swarm init --advertise-addr 198.51.100.48\n</code></pre>"},{"location":"#add-manager-nodes-optional","title":"Add manager nodes (optional)","text":"<ul> <li>On the main manager node, for each additional manager node you want to set up, run:</li> </ul> <pre><code>docker swarm join-token manager\n</code></pre> <ul> <li>Copy the result and paste it in the additional manager node's terminal, it will be something like:</li> </ul> <pre><code> docker swarm join --token SWMTKN-1-5tl7yaasdfd9qt9j0easdfnml4lqbosbasf14p13-f3hem9ckmkhasdf3idrzk5gz 192.0.2.175:2377\n</code></pre>"},{"location":"#add-worker-nodes-optional","title":"Add worker nodes (optional)","text":"<ul> <li>On the main manager node, for each additional worker node you want to set up, run:</li> </ul> <pre><code>docker swarm join-token worker\n</code></pre> <ul> <li>Copy the result and paste it in the additional worker node's terminal, it will be something like:</li> </ul> <pre><code>docker swarm join --token SWMTKN-1-5tl7ya98erd9qtasdfml4lqbosbhfqv3asdf4p13-dzw6ugasdfk0arn0 192.0.2.175:2377\n</code></pre>"},{"location":"#check-it","title":"Check it","text":"<ul> <li>Check that the cluster has all the nodes connected and set up:</li> </ul> <pre><code>docker node ls\n</code></pre> <p>It outputs something like:</p> <pre><code>ID                            HOSTNAME             STATUS    AVAILABILITY    MANAGER STATUS    ENGINE VERSION\nndcg2iavasdfrm6q2qwere2rr *   dog.example.com      Ready     Active          Leader            18.06.1-ce\n3jrutmd3asdf1ombqwerr9svk     cat.example.com      Ready     Active          Reachable         18.06.1-ce\ni9ec9hjasdfaoyyjqwerr3iqa     snake.example.com    Ready     Active          Reachable         18.06.1-ce\n</code></pre>"},{"location":"#done","title":"Done","text":"<p>That's it.</p> <p>You have a distributed Docker swarm mode cluster set up.</p> <p>Check other sections in the documentation at https://dockerswarm.khulnasoft.com to see how to set up HTTPS, you still have time, the 20 minutes are not over yet.</p> <p>Then you can see how to deploy stacks, etc.</p> <p>You already did the hard part, the rest is easy.</p>"},{"location":"gitlab-ci/","title":"GitLab CI runner for CI/CD","text":"<p>GitLab is an open source Git code management system, similar to GitHub and Bitbucket.</p> <p>It has integrated CI/CD (continuous integration and continuous deployment).</p> <p>If you are using GitLab, you can run a GitLab CI \"runner\" in your Docker Swarm mode cluster to test, build and deploy automatically your code.</p> <p>You could also test and build your code on \"runners\" in dedicated, isolated machines.</p> <p>And then deploy it to your production Docker Swarm mode cluster using another GitLab CI runner configured in the same cluster.</p>"},{"location":"gitlab-ci/#create-the-gitlab-runner-in-docker-standalone-mode","title":"Create the GitLab Runner in Docker standalone mode","text":"<p>You probably want to run the GitLab runner in Docker standalone, even when you deploy it in a Docker Swarm mode Manager Node to deploy production stacks.</p> <p>Technical details: This is because the Runner configurations will persist in the created container after the registration. If you create the GitLab Runner as a Docker Swarm mode service, your Runner could be deployed to a different Docker Swarm mode Manager Node the next time, or the container might be destroyed and replaced by a new one (even when running on the same machine), and then you would lose the registration configuration.</p> <ul> <li>To install a GitLab runner in a standalone Docker run:</li> </ul> <pre><code>docker run -d \\\n    --name gitlab-runner \\\n    --restart always \\\n    -v gitlab-runner:/etc/gitlab-runner \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    gitlab/gitlab-runner:latest\n</code></pre> <ul> <li>Then, enter into that container with a Bash session:</li> </ul> <pre><code>docker exec -it gitlab-runner bash\n</code></pre> <ul> <li>In a web browser, go to the GitLab \"Admin Area -&gt; Runners\" section.</li> <li>Get the URL and create an environment variable in your terminal running inside the Docker container, e.g.:</li> </ul> <pre><code>export GITLAB_URL=https://gitlab.example.com/\n</code></pre> <ul> <li>Get the registration token from the web browser in your GitLab and create an environment variable inside the Docker container, e.g.:</li> </ul> <pre><code>export GITLAB_TOKEN=WYasdfJp4sdfasdf1234\n</code></pre> <ul> <li>Run the next command editing the name and tags as you need.</li> </ul> <pre><code>gitlab-runner \\\n    register -n \\\n    --name \"Docker Runner\" \\\n    --executor docker \\\n    --docker-image docker:latest \\\n    --docker-volumes /var/run/docker.sock:/var/run/docker.sock \\\n    --url $GITLAB_URL \\\n    --registration-token $GITLAB_TOKEN \\\n    --tag-list dog-cat-cluster,stag,prod\n</code></pre> <ul> <li> <p>The runner will appear in your GitLab web user interface, in the runner's section.</p> </li> <li> <p>You can edit the runner data from the GitLab admin section (name, tags, etc).</p> </li> </ul>"},{"location":"gitlab-ci/#use-it","title":"Use it","text":"<p>GitLab CI is controlled using a <code>.gitlab-ci.yml</code> file that lives in your same code repository.</p> <p>To learn more about it, you can check GitLab CI's official documentation.</p> <p>If you have a Docker Swarm mode cluster with a main Traefik proxy set up using the ideas from DockerSwarm.rocks, your <code>.gitlab-ci.yml</code> file could look like:</p> <pre><code>image: khulnasoft/docker-with-compose\n\nbefore_script:\n  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY\n\nstages:\n  - build\n  - deploy\n\nbuild-prod:\n  stage: build\n  script:\n    - docker-compose build\n  only:\n    - master\n\ndeploy-prod:\n  stage: deploy\n  script:\n    - docker stack deploy -c docker-compose.yml --with-registry-auth my-stack\n  only:\n    - master\n</code></pre> <p>To see more complete examples, check the Project Generators at DockerSwarm.rocks.</p>"},{"location":"portainer/","title":"Portainer web user interface for your Docker Swarm cluster","text":"<p>Portainer is a web UI (user interface) that allows you to see the state of your Docker services in a Docker Swarm mode cluster and manage it.</p> <p>Follow this guide to integrate it in your Docker Swarm mode cluster deployed as described in DockerSwarm.rocks with a global Traefik HTTPS proxy.</p> <p>Here's one of the screens:</p> <p></p>"},{"location":"portainer/#preparation","title":"Preparation","text":"<ul> <li> <p>Connect via SSH to a Docker Swarm manager node.</p> </li> <li> <p>Create an environment variable with the domain where you want to access your Portainer instance, e.g.:</p> </li> </ul> <pre><code>export DOMAIN=portainer.sys.example.com\n</code></pre> <ul> <li> <p>Make sure that your DNS records point that domain (e.g. <code>portainer.sys.example.com</code>) to one of the IPs of the Docker Swarm mode cluster.</p> </li> <li> <p>Get the Swarm node ID of this (manager) node and store it in an environment variable:</p> </li> </ul> <pre><code>export NODE_ID=$(docker info -f '{{.Swarm.NodeID}}')\n</code></pre> <ul> <li>Create a tag in this node, so that Portainer is always deployed to the same node and uses the existing volume:</li> </ul> <pre><code>docker node update --label-add portainer.portainer-data=true $NODE_ID\n</code></pre>"},{"location":"portainer/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>portainer.yml</code>:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/portainer.yml -o portainer.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano portainer.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: '3.3'\n\nservices:\n  agent:\n    image: portainer/agent\n    environment:\n      AGENT_CLUSTER_ADDR: tasks.agent\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    networks:\n      - agent-network\n    deploy:\n      mode: global\n      placement:\n        constraints:\n          - node.platform.os == linux\n\n  portainer:\n    image: portainer/portainer-ce\n    command: -H tcp://tasks.agent:9001 --tlsskipverify\n    volumes:\n      - portainer-data:/data\n    networks:\n      - agent-network\n      - traefik-public\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n          - node.labels.portainer.portainer-data == true\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.portainer-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.portainer-http.entrypoints=http\n        - traefik.http.routers.portainer-http.middlewares=https-redirect\n        - traefik.http.routers.portainer-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.portainer-https.entrypoints=https\n        - traefik.http.routers.portainer-https.tls=true\n        - traefik.http.routers.portainer-https.tls.certresolver=le\n        - traefik.http.services.portainer.loadbalancer.server.port=9000\n\nnetworks:\n  agent-network:\n    attachable: true\n  traefik-public:\n    external: true\n\nvolumes:\n  portainer-data:\n</code></pre> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.portainer.yml</code>.</p> <p>Here it's named just <code>portainer.yml</code> for brevity.</p>"},{"location":"portainer/#deploy-it","title":"Deploy it","text":"<p>Deploy the stack with:</p> <pre><code>docker stack deploy -c portainer.yml portainer\n</code></pre> <p>It will use the environment variables you created above.</p>"},{"location":"portainer/#check-it","title":"Check it","text":"<ul> <li>Check if the stack was deployed with:</li> </ul> <pre><code>docker stack ps portainer\n</code></pre> <p>It will output something like:</p> <pre><code>ID             NAME                       IMAGE                        NODE              DESIRED STATE   CURRENT STATE          ERROR   PORT\nxvyasdfh56hg   portainer_agent.b282rzs5   portainer/agent:latest       dog.example.com   Running         Running 1 minute ago\nj3ahasdfe0mr   portainer_portainer.1      portainer/portainer:latest   cat.example.com   Running         Running 1 minute ago\n</code></pre> <ul> <li>You can check the Portainer logs with:</li> </ul> <pre><code>docker service logs portainer_portainer\n</code></pre>"},{"location":"portainer/#check-the-user-interface","title":"Check the user interface","text":"<p>After some seconds/minutes, Traefik will acquire the HTTPS certificates for the web user interface.</p> <p>You will be able to securely access the web UI at <code>https://&lt;your portainer domain&gt;</code> where you can create your username and password.</p>"},{"location":"portainer/#timing-note","title":"Timing Note","text":"<p>Make sure you login and create your credentials soon after Portainer is ready, or it will automatically shut down itself for security.</p> <p>If you didn't create the credentials on time and it shut down itself automatically, you can force it to restart with:</p> <pre><code>docker service update portainer_portainer --force\n</code></pre>"},{"location":"portainer/#references","title":"References","text":"<p>This guide on Portainer is adapted from the official Portainer documentation for Docker Swarm mode clusters, adding deployment restrictions to make sure the same volume and database is always used and to enable HTTPS via Traefik, using the same ideas from DockerSwarm.rocks.</p>"},{"location":"project-generators/","title":"Project Generators","text":"<p>There are several project generators designed to be used in a Docker Swarm mode cluster with a main Traefik HTTPS proxy, all set up with the ideas from DockerSwarm.rocks.</p>"},{"location":"project-generators/#full-stack-readyapi-postgresql-project-generator","title":"Full Stack ReadyAPI PostgreSQL - project generator","text":"<p>Link: https://github.com/khulnasoft/full-stack-readyapi-postgresql</p> <ul> <li>Python backend with ReadyAPI.</li> <li>Frontend with Vue.js.</li> <li>Celery for asynchronous jobs with RabbitMQ.</li> <li>PostgreSQL as the database.</li> <li>Email notifications.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#full-stack-readyapi-couchbase-project-generator","title":"Full Stack ReadyAPI Couchbase - project generator","text":"<p>Link: https://github.com/khulnasoft/full-stack-readyapi-couchbase</p> <ul> <li>Python backend with ReadyAPI.</li> <li>Frontend with Vue.js.</li> <li>Celery for asynchronous jobs with RabbitMQ.</li> <li>Couchbase as the NoSQL database.</li> <li>Email notifications.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#full-stack-flask-and-postgresql-project-generator","title":"Full Stack Flask and PostgreSQL - project generator","text":"<p>Link: https://github.com/khulnasoft/full-stack</p> <ul> <li>Python backend with Flask.</li> <li>Frontend with Vue.js.</li> <li>Celery for asynchronous jobs with RabbitMQ.</li> <li>PostgreSQL as the database.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#full-stack-flask-couchbase-project-generator","title":"Full Stack Flask Couchbase - project generator","text":"<p>Link: https://github.com/khulnasoft/full-stack-flask-couchbase</p> <ul> <li>Python backend with Flask.</li> <li>Frontend with Vue.js.</li> <li>Celery for asynchronous jobs with RabbitMQ.</li> <li>Couchbase as the NoSQL database.</li> <li>Email notifications.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#full-stack-flask-couchdb-project-generator","title":"Full Stack Flask CouchDB - project generator","text":"<p>Link: https://github.com/khulnasoft/full-stack-flask-couchdb</p> <ul> <li>Python backend with Flask.</li> <li>Frontend with Vue.js.</li> <li>Celery for asynchronous jobs with RabbitMQ.</li> <li>CouchDB as the NoSQL database.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#flask-frontend-docker-project-generator","title":"Flask Frontend Docker - project generator","text":"<p>Link: https://github.com/khulnasoft/flask-frontend-docker</p> <ul> <li>Python backend with Flask.</li> <li>Frontend with Vue.js.</li> <li>GitLab CI integration.</li> </ul>"},{"location":"project-generators/#terraform-ansible-docker-swarm-boilerplate-tads-project-generator","title":"Terraform + Ansible + Docker Swarm boilerplate (T.A.D.S.) - project generator","text":"<p>Link: https://github.com/Thomvaill/tads-boilerplate</p> <ul> <li>Cloud infrastructure created with Terraform.</li> <li>Production-like environment reproduced locally with Vagrant.</li> <li>Ansible provisioning (same playbooks for local machine and remote environments).</li> <li>Ansible again to deploy services (Traefik and your apps).</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#latest-changes","title":"Latest Changes","text":"<ul> <li>\u2b06 Update mkdocs-material requirement from 9.2.7 to 9.5.7. PR #129 by @dependabot[bot].</li> <li>\u2b06 Bump actions/setup-python from 4 to 5. PR #102 by @dependabot[bot].</li> <li>\ud83d\udea8 Deprecate website. PR #104 by @khulnasoft.</li> <li>\u270f Fix typo in comment for traefik-host.yml. PR #52 by @iRhonin.</li> <li>\ud83d\udc77 Add latest-changes GitHub action. PR #65 by @khulnasoft.</li> <li>Remove unwanted Swarmpit port 888. PR #51 by @inmishrar.</li> <li>Fix typo in YAML comment. PR #46 by @bmaggard.</li> <li>Reword comment about Traefik image to use. PR #45 by @bmaggard.</li> <li>Fix typo in comment on Traefik YAML file. PR #44 by @bmaggard.</li> <li>Add alternative way to type passwords interactively. PR #42.</li> <li>Add T.A.D.S. project generator. PR #36 by @Thomvaill.</li> </ul>"},{"location":"release-notes/#fixes","title":"Fixes","text":"<ul> <li>\ud83d\udc1b Fix main branch for building docs. PR #112 by @khulnasoft.</li> </ul>"},{"location":"release-notes/#docs","title":"Docs","text":"<ul> <li>\ud83d\udcdd Add note and link to Docker Swarm awesome list. PR #142 by @khulnasoft.</li> <li>\ud83d\udc1b Fix <code>cadvisor</code> image in Swarmprom, use Google Registry. PR #101 by @otterDeveloper.</li> <li>\ud83d\udcdd Tweak Swarmpit to use a new CouchDB with support for ARM. PR #114 by @khulnasoft.</li> <li>\u2728 Add Traefik v3 instructions. PR #93 by @rbauduin.</li> <li>\ud83d\udd27 Update Portainer. PR #113 by @khulnasoft.</li> <li>\ud83d\udcdd Do not use real public IPs in docs. PR #77 by @JakeDEvans.</li> </ul>"},{"location":"release-notes/#internal","title":"Internal","text":"<ul> <li>\ud83d\udc77 Update <code>labeler.yml</code>. PR #198 by @khulnasoft.</li> <li>\ud83d\udc77 Update worfkow deploy-docs-notify URL. PR #197 by @khulnasoft.</li> <li>\ud83d\udc77 Add labeler workflow. PR #196 by @khulnasoft.</li> <li>\u2b06 Bump mkdocs-material from 9.5.34 to 9.5.39. PR #194 by @dependabot[bot].</li> <li>\u2b06 Bump mkdocs-macros-plugin from 1.0.5 to 1.2.0. PR #189 by @dependabot[bot].</li> <li>\u2b06 Bump khulnasoft/issue-manager from 0.5.0 to 0.5.1. PR #188 by @dependabot[bot].</li> <li>\ud83d\udc77 Upgrade Cloudflare GitHub Action. PR #195 by @khulnasoft.</li> <li>\u2b06 Bump mkdocs-material from 9.5.18 to 9.5.34. PR #187 by @dependabot[bot].</li> <li>\u2b06 Bump cligenius from 0.12.3 to 0.12.5. PR #186 by @dependabot[bot].</li> <li>\u2b06 Bump pillow from 10.1.0 to 10.4.0. PR #172 by @dependabot[bot].</li> <li>\ud83d\udc77 Update <code>issue-manager.yml</code>. PR #185 by @khulnasoft.</li> <li>\ud83d\udc77 Update <code>build-docs.yml</code> GitHub Action <code>upload-artifact</code>. PR #184 by @khulnasoft.</li> <li>\ud83d\udc77 Update <code>build-docs.yml</code> GitHub Action <code>upload-artifact</code>. PR #183 by @khulnasoft.</li> <li>\ud83d\udc77 Update <code>latest-changes</code> GitHub Action. PR #182 by @khulnasoft.</li> <li>\ud83d\udd28 Update docs.py script to enable dirty reload conditionally. PR #178 by @khulnasoft.</li> <li>\ud83d\udd27 Update MkDocs previews. PR #177 by @khulnasoft.</li> <li>\ud83d\udc84 Update Termynal line-height. PR #176 by @khulnasoft.</li> <li>\ud83d\udc77 Upgrade build docs configs. PR #175 by @khulnasoft.</li> <li>\ud83d\udc77 Update docs-previews to handle no docs changes. PR #174 by @khulnasoft.</li> <li>\ud83d\udc77 Show docs deployment status and preview URLs in comment. PR #173 by @khulnasoft.</li> <li>\ud83d\ude48 Update gitignore. PR #171 by @khulnasoft.</li> <li>\u267b\ufe0f Update build docs setup. PR #169 by @khulnasoft.</li> <li>\ud83d\udc77 Update issue-manager.yml GitHub Action permissions. PR #167 by @khulnasoft.</li> <li>\ud83d\udc77 Refactor GitHub Action to comment docs deployment URLs and update token. PR #166 by @khulnasoft.</li> <li>\u2b06 Update pillow requirement from ^9.3.0 to ^10.3.0. PR #145 by @dependabot[bot].</li> <li>\u2b06 Update mkdocs-material requirement from 9.5.14 to 9.5.24. PR #159 by @dependabot[bot].</li> <li>\ud83d\udc77 Update GitHub Actions to download and upload artifacts. PR #156 by @khulnasoft.</li> <li>\u2b06 Bump dawidd6/action-download-artifact from 2.28.0 to 3.1.4. PR #141 by @dependabot[bot].</li> <li>\u2b06 Update mkdocs-material requirement from 9.5.7 to 9.5.14. PR #140 by @dependabot[bot].</li> <li>\u2b06 Bump khulnasoft/issue-manager from 0.4.1 to 0.5.0. PR #128 by @dependabot[bot].</li> <li>\u2b06 Bump actions/cache from 3 to 4. PR #124 by @dependabot[bot].</li> <li>\u2b06 Bump actions/upload-artifact from 3 to 4. PR #119 by @dependabot[bot].</li> <li>\ud83d\udd27 Add GitHub templates for discussions and issues, and security policy. PR #139 by @alejsdev.</li> <li>\u2b06 Bump khulnasoft/issue-manager from 0.4.0 to 0.4.1. PR #122 by @dependabot[bot].</li> <li>\ud83d\udcdd Update admonition syntax. PR #111 by @khulnasoft.</li> <li>\ud83d\udc77 Add GitHub Action to comment in PRs with previews. PR #110 by @khulnasoft.</li> <li>\ud83d\udc77 Deploy docs to Cloudflare. PR #109 by @khulnasoft.</li> <li>\ud83d\udc77 Update Dependabot. PR #105 by @khulnasoft.</li> <li>\u2b06 Bump actions/setup-python from 1 to 4. PR #97 by @dependabot[bot].</li> <li>\u2b06 Bump khulnasoft/issue-manager from 0.2.0 to 0.4.0. PR #98 by @dependabot[bot].</li> <li>\u2b06 Bump nwtgck/actions-netlify from 1.0.3 to 2.1.0. PR #99 by @dependabot[bot].</li> <li>\u2b06 Bump actions/checkout from 2 to 4. PR #100 by @dependabot[bot].</li> <li>\ud83d\udc77 Add dependabot. PR #96 by @khulnasoft.</li> <li>\ud83d\udc77 Update latest-changes GitHub Action. PR #94 by @khulnasoft.</li> <li>\ud83d\udc1b Fix config for latest-changes GitHub Action. PR #95 by @khulnasoft.</li> </ul>"},{"location":"release-notes/#030","title":"0.3.0","text":"<ul> <li>Add GitHub Sponsors button. PR #41.</li> <li>Simplify errors for env vars not set to make them consistent and re-usable. PR #40.</li> <li>Upgrade everything to use Traefik v2. PR #39.</li> <li>Update Portainer guide to use the same conventions for <code>DOMAIN</code> as the rest of the guides. PR #25 by @Mantosh.</li> <li>Add CI with GitHub actions to deploy to Netlify. PR #34.</li> <li>Move development dependencies from Pipenv to Poetry. PR #33.</li> <li>Update and simplify labels for redirections. PR #22 by @ldez.</li> <li>Add Issue Manager.</li> <li>Update Docker Compose files to show an error if the environment variables are not set. PR #15 by @dmrty.</li> <li>Update development dependencies for security.</li> <li>Add warning about <code>sudo</code> and environment variables. PR #13 by @dmontagu.</li> </ul>"},{"location":"release-notes/#020","title":"0.2.0","text":"<ul> <li>Add notes about starting Traefik in host mode. To be able to get the real IP from clients. Here's the updated documentation for distributed Traefik and here's the updated documentation for a single Traefik using a volume.</li> </ul>"},{"location":"release-notes/#010","title":"0.1.0","text":"<ul> <li>Add Swarmpit with deployment stack compatible with DockerSwarm.rocks.</li> </ul>"},{"location":"swarm-or-kubernetes/","title":"Docker Swarm Mode or Kubernetes","text":"<p>I was a big fan and advocate of Docker Swarm Mode.</p> <p>Unfortunately, it seems Kubernetes has the overwhelming majority of the market. \ud83e\udd72</p> <p>I think Docker Swarm Mode was a great product, and I didn't understand why it didn't get more adoption and kept growing.</p> <p>Right now, I think it's not sensible to build a new product using Docker Swarm Mode, just because there's no strong support behind it.</p> <p>I still think Kubernetes is overly complex for most cases, and I currently don't know of a better alternative (and I've tried several).</p> <p>I think deployment is not a solved problem.</p> <p>Maybe another abstraction layer simplifying everything is needed. Or maybe cloud services and platform as a service providers are just a better option now that the alternative is to go through the enormous complexity of Kubernetes.</p> <p>The safest bet right now seems to be using Kubernetes or managed cloud services, not Docker Swarm Mode.</p> <p>Given that, this website is deprecated, and kept around mainly for historical reasons.</p> <p>Sadly, I don't have a good alternative or set of guides to recommend or offer right now. You can follow me on Twitter or LinkedIn to see what else I discover in the future.</p> <p>Meanwhile, you could check the awesome-swarm list for more resources about Docker Swarm Mode. \ud83e\udd13</p>"},{"location":"swarm-or-kubernetes/#history","title":"History","text":"<p>Docker, Inc., the company, created Docker Swarm Mode, it was integrated in Docker, it was the competition of Kubernetes.</p> <p>At some point, Docker, Inc. decided to shift focus to Docker Desktop and other products. They sold all the Docker Swarm Mode side to Mirantis, Inc. that inherited the enterprise clients. And now Docker Swarm Mode is a Mirantis product under their Kubernetes engine.</p> <p>As someone looking from the outside, it seems Mirantis bought it to continue providing the enterprise support for the existing clients while probably helping them migrate to Kubernetes.</p> <p>It probably wouldn't make sense to create a new project based on Docker Swarm Mode instead of Kubernetes, when the current main company behind it is seemingly also fully focused on Kubernetes.</p>"},{"location":"swarmpit/","title":"Swarmpit web user interface for your Docker Swarm cluster","text":"<p>Swarmpit provides a nice and clean way to manage your Docker Swarm cluster.</p> <p>Follow this guide to integrate it in your Docker Swarm mode cluster deployed as described in DockerSwarm.rocks with a global Traefik HTTPS proxy.</p> <p>Here's one of the screens:</p> <p></p>"},{"location":"swarmpit/#preparation","title":"Preparation","text":"<ul> <li> <p>Connect via SSH to a Docker Swarm manager node.</p> </li> <li> <p>Create an environment variable with the domain where you want to access your Swarmpit instance, e.g.:</p> </li> </ul> <pre><code>export DOMAIN=swarmpit.sys.example.com\n</code></pre> <ul> <li> <p>Make sure that your DNS records point that domain (e.g. <code>swarmpit.sys.example.com</code>) to one of the IPs of the Docker Swarm mode cluster.</p> </li> <li> <p>Get the Swarm node ID of this (manager) node and store it in an environment variable:</p> </li> </ul> <pre><code>export NODE_ID=$(docker info -f '{{.Swarm.NodeID}}')\n</code></pre> <ul> <li>Create a label in this node, so that the CouchDB database used by Swarmpit is always deployed to the same node and uses the existing volume:</li> </ul> <pre><code>docker node update --label-add swarmpit.db-data=true $NODE_ID\n</code></pre> <ul> <li>Create another label in this node, so that the Influx database used by Swarmpit is always deployed to the same node and uses the existing volume:</li> </ul> <pre><code>docker node update --label-add swarmpit.influx-data=true $NODE_ID\n</code></pre>"},{"location":"swarmpit/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>swarmpit.yml</code>:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/swarmpit.yml -o swarmpit.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano swarmpit.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: '3.3'\n\nservices:\n  app:\n    image: swarmpit/swarmpit:latest\n    environment:\n      - SWARMPIT_DB=http://db:5984\n      - SWARMPIT_INFLUXDB=http://influxdb:8086\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    networks:\n      - net\n      - traefik-public\n    deploy:\n      resources:\n        limits:\n          cpus: '0.50'\n          memory: 1024M\n        reservations:\n          cpus: '0.25'\n          memory: 512M\n      placement:\n        constraints:\n          - node.role == manager\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.swarmpit-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmpit-http.entrypoints=http\n        - traefik.http.routers.swarmpit-http.middlewares=https-redirect\n        - traefik.http.routers.swarmpit-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmpit-https.entrypoints=https\n        - traefik.http.routers.swarmpit-https.tls=true\n        - traefik.http.routers.swarmpit-https.tls.certresolver=le\n        - traefik.http.services.swarmpit.loadbalancer.server.port=8080\n\n  db:\n    image: couchdb:2.3.1\n    volumes:\n      - db-data:/opt/couchdb/data\n    networks:\n      - net\n    deploy:\n      resources:\n        limits:\n          cpus: '0.30'\n          memory: 512M\n        reservations:\n          cpus: '0.15'\n          memory: 256M\n      placement:\n        constraints:\n          - node.labels.swarmpit.db-data == true\n  influxdb:\n    image: influxdb:1.7\n    volumes:\n      - influx-data:/var/lib/influxdb\n    networks:\n      - net\n    deploy:\n      resources:\n        reservations:\n          cpus: '0.3'\n          memory: 128M\n        limits:\n          cpus: '0.6'\n          memory: 512M\n      placement:\n        constraints:\n          - node.labels.swarmpit.influx-data == true\n  agent:\n    image: swarmpit/agent:latest\n    environment:\n      - DOCKER_API_VERSION=1.35\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    networks:\n      - net\n    deploy:\n      mode: global\n      resources:\n        limits:\n          cpus: '0.10'\n          memory: 64M\n        reservations:\n          cpus: '0.05'\n          memory: 32M\n\nnetworks:\n  net:\n    driver: overlay\n    attachable: true\n  traefik-public:\n    external: true\n\nvolumes:\n  db-data:\n    driver: local\n  influx-data:\n    driver: local\n</code></pre> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.swarmpit.yml</code>.</p> <p>Here it's named just <code>swarmpit.yml</code> for brevity.</p>"},{"location":"swarmpit/#deploy-it","title":"Deploy it","text":"<p>Deploy the stack with:</p> <pre><code>docker stack deploy -c swarmpit.yml swarmpit\n</code></pre> <p>It will use the environment variables you created above.</p>"},{"location":"swarmpit/#check-it","title":"Check it","text":"<ul> <li>Check if the stack was deployed with:</li> </ul> <pre><code>docker stack ps swarmpit\n</code></pre> <p>It will output something like:</p> <pre><code>ID             NAME                       IMAGE                      NODE                DESIRED STATE   CURRENT STATE          ERROR   PORT\nkkhasdfvce30   swarmpit_agent.ndasdfav5   swarmpit/agent:latest      dog.example.com     Running         Running 3 minutes ago\nk8oasdfg70jm   swarmpit_agent.i9asdfjps   swarmpit/agent:latest      cat.example.com     Running         Running 3 minutes ago\nkcvasdft0yzj   swarmpit_agent.3jasdfd3k   swarmpit/agent:latest      snake.example.com   Running         Running 3 minutes ago\n9onasdfzopve   swarmpit_agent.r6asdfb20   swarmpit/agent:latest      snake.example.com   Running         Running 3 minutes ago\nfxoasdfwjrbj   swarmpit_db.1              couchdb:2.3.1              dog.example.com     Running         Running 3 minutes ago\nm4jasdf3369c   swarmpit_app.1             swarmpit/swarmpit:latest   cat.example.com     Running         Running 3 minutes ago\n</code></pre> <ul> <li>You can check the Swarmpit logs with:</li> </ul> <pre><code>docker service logs swarmpit_app\n</code></pre>"},{"location":"swarmpit/#check-the-user-interfaces","title":"Check the user interfaces","text":"<p>After some seconds/minutes, Traefik will acquire the HTTPS certificates for the web user interface.</p> <p>You will be able to securely access the web UI at <code>https://&lt;your swarmpit domain&gt;</code> where you can create your username and password.</p>"},{"location":"swarmprom/","title":"Swarmprom for real-time monitoring and alerts","text":"<p>This article lives in:</p> <ul> <li>Medium</li> <li>GitHub</li> <li>DockerSwarm.rocks</li> </ul>"},{"location":"swarmprom/#intro","title":"Intro","text":"<p>Let's say you already set up a Docker Swarm mode cluster, with a Traefik HTTPS proxy.</p> <p>Here's how you can set up Swarmprom to monitor your cluster.</p> <p>It will allow you to:</p> <ul> <li>Monitor CPU, disk, memory usage, etc.</li> <li>Monitor it all per node, per service, per container, etc.</li> <li>Have a nice, interactive, real-time dashboard with all the data nicely plotted.</li> <li>Trigger alerts (for example, in Slack, Rocket.chat, etc) when your services/nodes pass certain thresholds.</li> <li>And more...</li> </ul> <p>Swarmprom is actually just a set of tools pre-configured in a smart way for a Docker Swarm cluster.</p> <p>It includes:</p> <ul> <li>Prometheus</li> <li>Grafana</li> <li>cAdvisor</li> <li>Node Exporter</li> <li>Alert Manager</li> <li>Unsee</li> </ul> <p>Here's how it looks like:</p> <p></p>"},{"location":"swarmprom/#instructions","title":"Instructions","text":"<ul> <li>Clone Swarmprom repository and enter into the directory:</li> </ul> <pre><code>$ git clone https://github.com/stefanprodan/swarmprom.git\n$ cd swarmprom\n</code></pre> <ul> <li>Set and export an <code>ADMIN_USER</code> environment variable:</li> </ul> <pre><code>export ADMIN_USER=admin\n</code></pre> <ul> <li>Set and export an <code>ADMIN_PASSWORD</code> environment variable:</li> </ul> <pre><code>export ADMIN_PASSWORD=changethis\n</code></pre> <ul> <li>Set and export a hashed version of the <code>ADMIN_PASSWORD</code> using <code>openssl</code>, it will be used by Traefik's HTTP Basic Auth for most of the services:</li> </ul> <pre><code>export HASHED_PASSWORD=$(openssl passwd -apr1 $ADMIN_PASSWORD)\n</code></pre> <p>(Optional): Alternatively, if you don't want to put the password in an environment variable, you could type it interactively, e.g.:</p> <pre><code>$ export HASHED_PASSWORD=$(openssl passwd -apr1)\nPassword: $ enter your password here\nVerifying - Password: $ re enter your password here\n</code></pre> <ul> <li>You can check the contents with:</li> </ul> <pre><code>echo $HASHED_PASSWORD\n</code></pre> <p>it will look like:</p> <pre><code>$apr1$89eqM5Ro$CxaFELthUKV21DpI3UTQO.\n</code></pre> <ul> <li>Create and export an environment variable <code>DOMAIN</code>, e.g.:</li> </ul> <pre><code>export DOMAIN=example.com\n</code></pre> <p>and make sure that the following sub-domains point to your Docker Swarm cluster IPs:</p> <ul> <li><code>grafana.example.com</code></li> <li><code>alertmanager.example.com</code></li> <li><code>unsee.example.com</code></li> <li><code>prometheus.example.com</code></li> </ul> <p>(and replace <code>example.com</code> with your actual domain).</p> <p>Note: You can also use a subdomain, like <code>swarmprom.example.com</code>. Just make sure that the subdomains point to (at least one of) your cluster IPs. Or set up a wildcard subdomain (<code>*</code>).</p> <ul> <li>If you are using Slack and want to integrate it, set the following environment variables:</li> </ul> <pre><code>export SLACK_URL=https://hooks.slack.com/services/TOKEN\nexport SLACK_CHANNEL=devops-alerts\nexport SLACK_USER=alertmanager\n</code></pre> <p>Note: by using <code>export</code> when declaring all the environment variables above, the next command will be able to use them.</p>"},{"location":"swarmprom/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>swarmprom.yml</code>:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/swarmprom.yml -o swarmprom.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano swarmprom.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: \"3.3\"\n\nnetworks:\n  net:\n    driver: overlay\n    attachable: true\n  traefik-public:\n    external: true\n\nvolumes:\n    prometheus: {}\n    grafana: {}\n    alertmanager: {}\n\nconfigs:\n  dockerd_config:\n    file: ./dockerd-exporter/Caddyfile\n  node_rules:\n    file: ./prometheus/rules/swarm_node.rules.yml\n  task_rules:\n    file: ./prometheus/rules/swarm_task.rules.yml\n\nservices:\n  dockerd-exporter:\n    image: stefanprodan/caddy\n    networks:\n      - net\n    environment:\n      - DOCKER_GWBRIDGE_IP=172.18.0.1\n    configs:\n      - source: dockerd_config\n        target: /etc/caddy/Caddyfile\n    deploy:\n      mode: global\n      resources:\n        limits:\n          memory: 128M\n        reservations:\n          memory: 64M\n\n  cadvisor:\n    image: gcr.io/cadvisor/cadvisor\n    networks:\n      - net\n    command: -logtostderr -docker_only\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - /:/rootfs:ro\n      - /var/run:/var/run\n      - /sys:/sys:ro\n      - /var/lib/docker/:/var/lib/docker:ro\n    deploy:\n      mode: global\n      resources:\n        limits:\n          memory: 128M\n        reservations:\n          memory: 64M\n\n  grafana:\n    image: stefanprodan/swarmprom-grafana:5.3.4\n    networks:\n      - default\n      - net\n      - traefik-public\n    environment:\n      - GF_SECURITY_ADMIN_USER=${ADMIN_USER:-admin}\n      - GF_SECURITY_ADMIN_PASSWORD=${ADMIN_PASSWORD:-admin}\n      - GF_USERS_ALLOW_SIGN_UP=false\n      #- GF_SERVER_ROOT_URL=${GF_SERVER_ROOT_URL:-localhost}\n      #- GF_SMTP_ENABLED=${GF_SMTP_ENABLED:-false}\n      #- GF_SMTP_FROM_ADDRESS=${GF_SMTP_FROM_ADDRESS:-grafana@test.com}\n      #- GF_SMTP_FROM_NAME=${GF_SMTP_FROM_NAME:-Grafana}\n      #- GF_SMTP_HOST=${GF_SMTP_HOST:-smtp:25}\n      #- GF_SMTP_USER=${GF_SMTP_USER}\n      #- GF_SMTP_PASSWORD=${GF_SMTP_PASSWORD}\n    volumes:\n      - grafana:/var/lib/grafana\n    deploy:\n      mode: replicated\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n      resources:\n        limits:\n          memory: 128M\n        reservations:\n          memory: 64M\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.swarmprom-grafana-http.rule=Host(`grafana.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-grafana-http.entrypoints=http\n        - traefik.http.routers.swarmprom-grafana-http.middlewares=https-redirect\n        - traefik.http.routers.swarmprom-grafana-https.rule=Host(`grafana.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-grafana-https.entrypoints=https\n        - traefik.http.routers.swarmprom-grafana-https.tls=true\n        - traefik.http.routers.swarmprom-grafana-https.tls.certresolver=le\n        - traefik.http.services.swarmprom-grafana.loadbalancer.server.port=3000\n\n  alertmanager:\n    image: stefanprodan/swarmprom-alertmanager:v0.14.0\n    networks:\n      - default\n      - net\n      - traefik-public\n    environment:\n      - SLACK_URL=${SLACK_URL:-https://hooks.slack.com/services/TOKEN}\n      - SLACK_CHANNEL=${SLACK_CHANNEL:-general}\n      - SLACK_USER=${SLACK_USER:-alertmanager}\n    command:\n      - '--config.file=/etc/alertmanager/alertmanager.yml'\n      - '--storage.path=/alertmanager'\n    volumes:\n      - alertmanager:/alertmanager\n    deploy:\n      mode: replicated\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n      resources:\n        limits:\n          memory: 128M\n        reservations:\n          memory: 64M\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.swarmprom-alertmanager-http.rule=Host(`alertmanager.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-alertmanager-http.entrypoints=http\n        - traefik.http.routers.swarmprom-alertmanager-http.middlewares=https-redirect\n        - traefik.http.routers.swarmprom-alertmanager-https.rule=Host(`alertmanager.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-alertmanager-https.entrypoints=https\n        - traefik.http.routers.swarmprom-alertmanager-https.tls=true\n        - traefik.http.routers.swarmprom-alertmanager-https.tls.certresolver=le\n        - traefik.http.services.swarmprom-alertmanager.loadbalancer.server.port=9093\n        - traefik.http.middlewares.swarmprom-alertmanager-auth.basicauth.users=${ADMIN_USER?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        - traefik.http.routers.swarmprom-alertmanager-https.middlewares=swarmprom-alertmanager-auth\n\n  unsee:\n    image: cloudflare/unsee:v0.8.0\n    networks:\n      - default\n      - net\n      - traefik-public\n    environment:\n      - \"ALERTMANAGER_URIS=default:http://alertmanager:9093\"\n    deploy:\n      mode: replicated\n      replicas: 1\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.swarmprom-unsee-http.rule=Host(`unsee.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-unsee-http.entrypoints=http\n        - traefik.http.routers.swarmprom-unsee-http.middlewares=https-redirect\n        - traefik.http.routers.swarmprom-unsee-https.rule=Host(`unsee.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-unsee-https.entrypoints=https\n        - traefik.http.routers.swarmprom-unsee-https.tls=true\n        - traefik.http.routers.swarmprom-unsee-https.tls.certresolver=le\n        - traefik.http.services.swarmprom-unsee.loadbalancer.server.port=8080\n        - traefik.http.middlewares.swarmprom-unsee-auth.basicauth.users=${ADMIN_USER?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        - traefik.http.routers.swarmprom-unsee-https.middlewares=swarmprom-unsee-auth\n\n  node-exporter:\n    image: stefanprodan/swarmprom-node-exporter:v0.16.0\n    networks:\n      - net\n    environment:\n      - NODE_ID={{.Node.ID}}\n    volumes:\n      - /proc:/host/proc:ro\n      - /sys:/host/sys:ro\n      - /:/rootfs:ro\n      - /etc/hostname:/etc/nodename\n    command:\n      - '--path.sysfs=/host/sys'\n      - '--path.procfs=/host/proc'\n      - '--collector.textfile.directory=/etc/node-exporter/'\n      - '--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|host|etc)($$|/)'\n      - '--no-collector.ipvs'\n    deploy:\n      mode: global\n      resources:\n        limits:\n          memory: 128M\n        reservations:\n          memory: 64M\n\n  prometheus:\n    image: stefanprodan/swarmprom-prometheus:v2.5.0\n    networks:\n      - default\n      - net\n      - traefik-public\n    command:\n      - '--config.file=/etc/prometheus/prometheus.yml'\n      - '--storage.tsdb.path=/prometheus'\n      - '--storage.tsdb.retention=${PROMETHEUS_RETENTION:-24h}'\n    volumes:\n      - prometheus:/prometheus\n    configs:\n      - source: node_rules\n        target: /etc/prometheus/swarm_node.rules.yml\n      - source: task_rules\n        target: /etc/prometheus/swarm_task.rules.yml\n    deploy:\n      mode: replicated\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n      resources:\n        limits:\n          memory: 2048M\n        reservations:\n          memory: 128M\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.swarmprom-prometheus-http.rule=Host(`prometheus.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-prometheus-http.entrypoints=http\n        - traefik.http.routers.swarmprom-prometheus-http.middlewares=https-redirect\n        - traefik.http.routers.swarmprom-prometheus-https.rule=Host(`prometheus.${DOMAIN?Variable not set}`)\n        - traefik.http.routers.swarmprom-prometheus-https.entrypoints=https\n        - traefik.http.routers.swarmprom-prometheus-https.tls=true\n        - traefik.http.routers.swarmprom-prometheus-https.tls.certresolver=le\n        - traefik.http.services.swarmprom-prometheus.loadbalancer.server.port=9090\n        - traefik.http.middlewares.swarmprom-prometheus-auth.basicauth.users=${ADMIN_USER?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        - traefik.http.routers.swarmprom-prometheus-https.middlewares=swarmprom-prometheus-auth\n</code></pre> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.swarmprom.yml</code>.</p> <p>Here it's named just <code>swarmprom.yml</code> for brevity.</p> <ul> <li>Deploy the Traefik version of the stack:</li> </ul> <pre><code>docker stack deploy -c swarmprom.yml swarmprom\n</code></pre> <p>To test it, go to each URL:</p> <ul> <li><code>https://grafana.example.com</code></li> <li><code>https://alertmanager.example.com</code></li> <li><code>https://unsee.example.com</code></li> <li><code>https://prometheus.example.com</code></li> </ul>"},{"location":"thelounge/","title":"The Lounge - self-hosted web IRC client","text":"<p>The Lounge is a self-hosted web IRC client.</p> <p>Follow this guide to integrate it in your Docker Swarm mode cluster deployed as described in DockerSwarm.rocks with a global Traefik HTTPS proxy.</p>"},{"location":"thelounge/#preparation","title":"Preparation","text":"<ul> <li> <p>Connect via SSH to a Docker Swarm manager node.</p> </li> <li> <p>Create an environment variable with the domain where you want to access your instance, e.g.:</p> </li> </ul> <pre><code>export DOMAIN=thelounge.example.com\n</code></pre> <ul> <li> <p>Make sure that your DNS records point that domain (e.g. <code>thelounge.example.com</code>) to one of the IPs of the Docker Swarm mode cluster.</p> </li> <li> <p>Get the Swarm node ID of this node (or any other node) and store it in an environment variable:</p> </li> </ul> <pre><code>export NODE_ID=$(docker info -f '{{.Swarm.NodeID}}')\n</code></pre> <ul> <li>Create a tag in this node, so that the data used by The Lounge is always deployed to the same node and uses the existing volume:</li> </ul> <pre><code>docker node update --label-add thelounge.thelounge-data=true $NODE_ID\n</code></pre>"},{"location":"thelounge/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>thelounge.yml</code>:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/thelounge.yml -o thelounge.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano thelounge.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: '3.3'\n\nservices:\n  app:\n    image: thelounge/thelounge:latest\n    volumes:\n      - thelounge-data:/var/opt/thelounge\n    networks:\n      - traefik-public\n    deploy:\n      placement:\n        constraints:\n          - node.labels.thelounge.thelounge-data == true\n      labels:\n        - traefik.enable=true\n        - traefik.docker.network=traefik-public\n        - traefik.constraint-label=traefik-public\n        - traefik.http.routers.thelounge-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.thelounge-http.entrypoints=http\n        - traefik.http.routers.thelounge-http.middlewares=https-redirect\n        - traefik.http.routers.thelounge-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.thelounge-https.entrypoints=https\n        - traefik.http.routers.thelounge-https.tls=true\n        - traefik.http.routers.thelounge-https.tls.certresolver=le\n        - traefik.http.services.thelounge.loadbalancer.server.port=9000\n\nnetworks:\n  traefik-public:\n    external: true\n\nvolumes:\n  thelounge-data:\n</code></pre> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.thelounge.yml</code>.</p> <p>Here it's named just <code>thelounge.yml</code> for brevity.</p>"},{"location":"thelounge/#deploy-it","title":"Deploy it","text":"<p>Deploy the stack with:</p> <pre><code>docker stack deploy -c thelounge.yml thelounge\n</code></pre> <p>It will use the environment variables you created above.</p>"},{"location":"thelounge/#check-it","title":"Check it","text":"<ul> <li>Check if the stack was deployed with:</li> </ul> <pre><code>docker stack ps thelounge\n</code></pre> <p>It will output something like:</p> <pre><code>ID             NAME               IMAGE                         NODE               DESIRED STATE    CURRENT STATE          ERROR   PORT\nkxdsp9f1nuil   thelounge_app.1    thelounge/thelounge:latest    dog.example.com    Running          Running 7 seconds ago\n</code></pre> <ul> <li>You can check the logs with:</li> </ul> <pre><code>docker service logs thelounge_app\n</code></pre> <p>...you might see a message like:</p> <pre><code>thelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:42 [INFO] Configuration file created at /var/opt/thelounge/config.js.\nthelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:43 [INFO] The Lounge v3.0.1 (Node.js 10.15.1 on linux x64)\nthelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:43 [INFO] Configuration file: /var/opt/thelounge/config.js\nthelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:43 [INFO] Available at http://:::9000/ in private mode\nthelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:43 [INFO] New VAPID key pair has been generated for use with push subscription.\nthelounge_app.1.kxdsp9f1nuil@dog.example.com    | 2019-05-12 09:58:43 [INFO] There are currently no users. Create one with thelounge add &lt;name&gt;.\n</code></pre>"},{"location":"thelounge/#create-a-user","title":"Create a user","text":"<ul> <li>Now, to create a user, enter into a bash session inside the running container, type:</li> </ul> <pre><code>docker exec -it thelounge_app\n</code></pre> <p>and hit <code>Tab</code> to get autocompletion, then type <code>bash</code>. It would look something like:</p> <pre><code>docker exec -it thelounge_app.1.kxdsp9f1nuilj0vclhhfuc4ho bash\n</code></pre> <p>Then hit <code>Enter</code>, you will be in a bash session inside the running container.</p> <p>You will see a prompt like:</p> <pre><code>root@61d7cc2c6e44:/#\n</code></pre> <ul> <li>Now create the user, if the user is named <code>admin</code>, it would be something like:</li> </ul> <pre><code>thelounge add admin\n</code></pre> <ul> <li>You will see a prompt for a password. Enter your password and hit <code>Enter</code>.</li> <li>It will ask you if you want to save, hit <code>Enter</code> again and the user will be created.</li> </ul>"},{"location":"thelounge/#login-and-configure","title":"Login and configure","text":"<p>Now you can open the URL in your browser, e.g.: <code>https://thelounge.example.com</code>.</p> <p>Use the user and password you just created and finish configuring it in the web browser.</p>"},{"location":"traefik/","title":"Traefik Proxy with HTTPS","text":""},{"location":"traefik/#note-version-2-and-v3","title":"Note - version 2 (and v3)","text":"<p>This guide is updated for Traefik version 2 and version 3. \u2728</p> <p>If you are looking for the previous guides for Traefik version 1, check them in DockerSwarm.rocks/traefik-v1/. Using Traefik 3 is only one line difference in the YAML used to deploy Traefik, and is detailed below.</p> <p>Note</p> <p>There are many applications and some project generators based on the previous guides for Traefik version 1.</p> <p>If you have something already deployed, there are chances it uses those previous guides.</p> <p>But for new projects, continue here. \ud83d\ude80</p>"},{"location":"traefik/#intro","title":"Intro","text":"<p>So, you have a Docker Swarm mode cluster set up as described in DockerSwarm.rocks.</p> <p>Now you can add a main Traefik load balancer/proxy to:</p> <ul> <li>Handle connections.</li> <li>Expose specific services and applications based on their domain names.</li> <li>Handle multiple domains (if you need to). Similar to \"virtual hosts\".</li> <li>Handle HTTPS.</li> <li>Acquire (generate) HTTPS certificates automatically (including renewals) with Let's Encrypt.</li> <li>Add HTTP Basic Auth for any service that you need to protect and doesn't have its own security, etc.</li> <li>Get all its configurations automatically from Docker labels set in your stacks (you don't need to update configuration files).</li> </ul> <p>These ideas, techniques, and tools would also apply to other cluster orchestrators, like Kubernetes or Mesos, to add a main load balancer with HTTPS support, certificate generation, etc. But this article is focused on Docker Swarm mode.</p>"},{"location":"traefik/#user-interface","title":"User Interface","text":"<p>The guide includes how to expose the internal Traefik web UI dashboard through the same Traefik load balancer, using a secure HTTPS certificate and HTTP Basic Auth.</p> <p></p>"},{"location":"traefik/#how-it-works","title":"How it works","text":"<p>The idea is to have a main load balancer/proxy that covers all the Docker Swarm cluster and handles HTTPS certificates and requests for each domain.</p> <p>But doing it in a way that allows you to have other Traefik services inside each stack without interfering with each other, to redirect based on path in the same stack (e.g. one container handles <code>/</code> for a web frontend and another handles <code>/api</code> for an API under the same domain), or to redirect from HTTP to HTTPS selectively.</p>"},{"location":"traefik/#preparation","title":"Preparation","text":"<ul> <li>Connect via SSH to a manager node in your cluster (you might have only one node) that will have the Traefik service.</li> <li>Create a network that will be shared with Traefik and the containers that should be accessible from the outside, with:</li> </ul> <pre><code>docker network create --driver=overlay traefik-public\n</code></pre> <ul> <li>Get the Swarm node ID of this node and store it in an environment variable:</li> </ul> <pre><code>export NODE_ID=$(docker info -f '{{.Swarm.NodeID}}')\n</code></pre> <ul> <li>Create a tag in this node, so that Traefik is always deployed to the same node and uses the same volume:</li> </ul> <pre><code>docker node update --label-add traefik-public.traefik-public-certificates=true $NODE_ID\n</code></pre> <ul> <li>Create an environment variable with your email, to be used for the generation of Let's Encrypt certificates, e.g.:</li> </ul> <pre><code>export EMAIL=admin@example.com\n</code></pre> <ul> <li>Create an environment variable with the domain you want to use for the Traefik UI (user interface), e.g.:</li> </ul> <pre><code>export DOMAIN=traefik.sys.example.com\n</code></pre> <ul> <li> <p>You will access the Traefik dashboard at this domain, e.g. <code>traefik.sys.example.com</code>. So, make sure that your DNS records point the domain to one of the IPs of the cluster. Better if it is the IP where the Traefik service runs (the manager node you are currently connected to).</p> </li> <li> <p>Create an environment variable with a username (you will use it for the HTTP Basic Auth for Traefik and Consul UIs), for example:</p> </li> </ul> <pre><code>export USERNAME=admin\n</code></pre> <ul> <li>Create an environment variable with the password, e.g.:</li> </ul> <pre><code>export PASSWORD=changethis\n</code></pre> <ul> <li>Use <code>openssl</code> to generate the \"hashed\" version of the password and store it in an environment variable:</li> </ul> <pre><code>export HASHED_PASSWORD=$(openssl passwd -apr1 $PASSWORD)\n</code></pre> <p>(Optional): Alternatively, if you don't want to put the password in an environment variable, you could type it interactively, e.g.:</p> <pre><code>$ export HASHED_PASSWORD=$(openssl passwd -apr1)\nPassword: $ enter your password here\nVerifying - Password: $ re enter your password here\n</code></pre> <ul> <li>You can check the contents with:</li> </ul> <pre><code>echo $HASHED_PASSWORD\n</code></pre> <p>It will look like:</p> <pre><code>$apr1$89eqM5Ro$CxaFELthUKV21DpI3UTQO.\n</code></pre>"},{"location":"traefik/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>traefik.yml</code> for Traefik v2:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/traefik.yml -o traefik.yml\n</code></pre> <p>or <code>traefik-v3.yml</code> for Traefik 3</p> <pre><code>curl -L dockerswarm.khulnasoft.com/traefik-v3.yml -o traefik.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano traefik.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: '3.3'\n\nservices:\n\n  traefik:\n    # Use the latest v2.2.x Traefik image available\n    image: traefik:v2.2\n    ports:\n      # Listen on port 80, default for HTTP, necessary to redirect to HTTPS\n      - 80:80\n      # Listen on port 443, default for HTTPS\n      - 443:443\n    deploy:\n      placement:\n        constraints:\n          # Make the traefik service run only on the node with this label\n          # as the node with it has the volume for the certificates\n          - node.labels.traefik-public.traefik-public-certificates == true\n      labels:\n        # Enable Traefik for this service, to make it available in the public network\n        - traefik.enable=true\n        # Use the traefik-public network (declared below)\n        - traefik.docker.network=traefik-public\n        # Use the custom label \"traefik.constraint-label=traefik-public\"\n        # This public Traefik will only use services with this label\n        # That way you can add other internal Traefik instances per stack if needed\n        - traefik.constraint-label=traefik-public\n        # admin-auth middleware with HTTP Basic auth\n        # Using the environment variables USERNAME and HASHED_PASSWORD\n        - traefik.http.middlewares.admin-auth.basicauth.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        # https-redirect middleware to redirect HTTP to HTTPS\n        # It can be re-used by other stacks in other Docker Compose files\n        - traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\n        - traefik.http.middlewares.https-redirect.redirectscheme.permanent=true\n        # traefik-http set up only to use the middleware to redirect to https\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-http.entrypoints=http\n        - traefik.http.routers.traefik-public-http.middlewares=https-redirect\n        # traefik-https the actual router using HTTPS\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-https.entrypoints=https\n        - traefik.http.routers.traefik-public-https.tls=true\n        # Use the special Traefik service api@internal with the web UI/Dashboard\n        - traefik.http.routers.traefik-public-https.service=api@internal\n        # Use the \"le\" (Let's Encrypt) resolver created below\n        - traefik.http.routers.traefik-public-https.tls.certresolver=le\n        # Enable HTTP Basic auth, using the middleware created above\n        - traefik.http.routers.traefik-public-https.middlewares=admin-auth\n        # Define the port inside of the Docker service to use\n        - traefik.http.services.traefik-public.loadbalancer.server.port=8080\n    volumes:\n      # Add Docker as a mounted volume, so that Traefik can read the labels of other services\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      # Mount the volume to store the certificates\n      - traefik-public-certificates:/certificates\n    command:\n      # Enable Docker in Traefik, so that it reads labels from Docker services\n      - --providers.docker\n      # Add a constraint to only use services with the label \"traefik.constraint-label=traefik-public\"\n      - --providers.docker.constraints=Label(`traefik.constraint-label`, `traefik-public`)\n      # Do not expose all Docker services, only the ones explicitly exposed\n      - --providers.docker.exposedbydefault=false\n      # Enable Docker Swarm mode\n      - --providers.docker.swarmmode\n      # Create an entrypoint \"http\" listening on port 80\n      - --entrypoints.http.address=:80\n      # Create an entrypoint \"https\" listening on port 443\n      - --entrypoints.https.address=:443\n      # Create the certificate resolver \"le\" for Let's Encrypt, uses the environment variable EMAIL\n      - --certificatesresolvers.le.acme.email=${EMAIL?Variable not set}\n      # Store the Let's Encrypt certificates in the mounted volume\n      - --certificatesresolvers.le.acme.storage=/certificates/acme.json\n      # Use the TLS Challenge for Let's Encrypt\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # Enable the access log, with HTTP requests\n      - --accesslog\n      # Enable the Traefik log, for configurations and errors\n      - --log\n      # Enable the Dashboard and API\n      - --api\n    networks:\n      # Use the public network created to be shared between Traefik and\n      # any other service that needs to be publicly available with HTTPS\n      - traefik-public\n\nvolumes:\n  # Create a volume to store the certificates, there is a constraint to make sure\n  # Traefik is always deployed to the same Docker node with the same volume containing\n  # the HTTPS certificates\n  traefik-public-certificates:\n\nnetworks:\n  # Use the previously created public network \"traefik-public\", shared with other\n  # services that need to be publicly available via this Traefik\n  traefik-public:\n    external: true\n</code></pre> <p>or for Traefik 3, where the only difference is how the swarm mode is activated:</p> Traefik 3 <pre><code>version: '3.3'\n\nservices:\n\n  traefik:\n    # Use the latest v3.0.x Traefik image available\n    image: traefik:v3.0\n    ports:\n      # Listen on port 80, default for HTTP, necessary to redirect to HTTPS\n      - 80:80\n      # Listen on port 443, default for HTTPS\n      - 443:443\n    deploy:\n      placement:\n        constraints:\n          # Make the traefik service run only on the node with this label\n          # as the node with it has the volume for the certificates\n          - node.labels.traefik-public.traefik-public-certificates == true\n      labels:\n        # Enable Traefik for this service, to make it available in the public network\n        - traefik.enable=true\n        # Use the traefik-public network (declared below)\n        - traefik.docker.network=traefik-public\n        # Use the custom label \"traefik.constraint-label=traefik-public\"\n        # This public Traefik will only use services with this label\n        # That way you can add other internal Traefik instances per stack if needed\n        - traefik.constraint-label=traefik-public\n        # admin-auth middleware with HTTP Basic auth\n        # Using the environment variables USERNAME and HASHED_PASSWORD\n        - traefik.http.middlewares.admin-auth.basicauth.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        # https-redirect middleware to redirect HTTP to HTTPS\n        # It can be re-used by other stacks in other Docker Compose files\n        - traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\n        - traefik.http.middlewares.https-redirect.redirectscheme.permanent=true\n        # traefik-http set up only to use the middleware to redirect to https\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-http.entrypoints=http\n        - traefik.http.routers.traefik-public-http.middlewares=https-redirect\n        # traefik-https the actual router using HTTPS\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-https.entrypoints=https\n        - traefik.http.routers.traefik-public-https.tls=true\n        # Use the special Traefik service api@internal with the web UI/Dashboard\n        - traefik.http.routers.traefik-public-https.service=api@internal\n        # Use the \"le\" (Let's Encrypt) resolver created below\n        - traefik.http.routers.traefik-public-https.tls.certresolver=le\n        # Enable HTTP Basic auth, using the middleware created above\n        - traefik.http.routers.traefik-public-https.middlewares=admin-auth\n        # Define the port inside of the Docker service to use\n        - traefik.http.services.traefik-public.loadbalancer.server.port=8080\n    volumes:\n      # Add Docker as a mounted volume, so that Traefik can read the labels of other services\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      # Mount the volume to store the certificates\n      - traefik-public-certificates:/certificates\n    command:\n      # Enable Docker in Traefik, so that it reads labels from Docker services\n      - --providers.docker\n      # Add a constraint to only use services with the label \"traefik.constraint-label=traefik-public\"\n      - --providers.docker.constraints=Label(`traefik.constraint-label`, `traefik-public`)\n      # Do not expose all Docker services, only the ones explicitly exposed\n      - --providers.docker.exposedbydefault=false\n      # Enable Docker Swarm mode\n      - --providers.swarm.endpoint=unix:///var/run/docker.sock\n      # Create an entrypoint \"http\" listening on port 80\n      - --entrypoints.http.address=:80\n      # Create an entrypoint \"https\" listening on port 443\n      - --entrypoints.https.address=:443\n      # Create the certificate resolver \"le\" for Let's Encrypt, uses the environment variable EMAIL\n      - --certificatesresolvers.le.acme.email=${EMAIL?Variable not set}\n      # Store the Let's Encrypt certificates in the mounted volume\n      - --certificatesresolvers.le.acme.storage=/certificates/acme.json\n      # Use the TLS Challenge for Let's Encrypt\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # Enable the access log, with HTTP requests\n      - --accesslog\n      # Enable the Traefik log, for configurations and errors\n      - --log\n      # Enable the Dashboard and API\n      - --api\n    networks:\n      # Use the public network created to be shared between Traefik and\n      # any other service that needs to be publicly available with HTTPS\n      - traefik-public\n\nvolumes:\n  # Create a volume to store the certificates, there is a constraint to make sure\n  # Traefik is always deployed to the same Docker node with the same volume containing\n  # the HTTPS certificates\n  traefik-public-certificates:\n\nnetworks:\n  # Use the previously created public network \"traefik-public\", shared with other\n  # services that need to be publicly available via this Traefik\n  traefik-public:\n    external: true\n</code></pre> <p>Tip</p> <p>Read the internal comments to learn what each configuration is for.</p> <p>The file without comments is actually quite smaller, but the comments should give you an idea of what everything is doing.</p> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.traefik.yml</code>.</p> <p>Here it's named just <code>traefik.yml</code> for brevity.</p>"},{"location":"traefik/#deploy-it","title":"Deploy it","text":"<p>Deploy the stack with:</p> <pre><code>docker stack deploy -c traefik.yml traefik\n</code></pre> <p>It will use the environment variables you created above.</p>"},{"location":"traefik/#check-it","title":"Check it","text":"<ul> <li>Check if the stack was deployed with:</li> </ul> <pre><code>docker stack ps traefik\n</code></pre> <p>It will output something like:</p> <pre><code>ID             NAME                IMAGE          NODE              DESIRED STATE   CURRENT STATE          ERROR   PORTS\nw5o6fmmln8ni   traefik_traefik.1   traefik:v2.2   dog.example.com   Running         Running 1 minute ago\n</code></pre> <ul> <li>You can check the Traefik logs with:</li> </ul> <pre><code>docker service logs traefik_traefik\n</code></pre>"},{"location":"traefik/#check-the-user-interface","title":"Check the user interface","text":"<p>After some seconds/minutes, Traefik will acquire the HTTPS certificates for the web user interface (UI).</p> <p>You will be able to securely access the web UI at <code>https://traefik.&lt;your domain&gt;</code> using the created username and password.</p> <p>Once you deploy a stack, you will be able to see it there and see how the different hosts and paths map to different Docker services / containers.</p>"},{"location":"traefik/#getting-the-client-ip","title":"Getting the client IP","text":"<p>If you need to read the client IP in your applications/stacks using the <code>X-Forwarded-For</code> or <code>X-Real-IP</code> headers provided by Traefik, you need to make Traefik listen directly, not through Docker Swarm mode, even while being deployed with Docker Swarm mode.</p> <p>For that, you need to publish the ports using \"host\" mode.</p> <p>So, the Docker Compose lines:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n</code></pre> <p>need to be:</p> <pre><code>    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n</code></pre> <p>You can use all the same instructions above, downloading the host-mode file:</p> <pre><code>curl -L dockerswarm.khulnasoft.com/traefik-host.yml -o traefik-host.yml\n</code></pre> <p>Or alternatively, copying it directly:</p> <pre><code>version: '3.3'\n\nservices:\n\n  traefik:\n    # Use the latest Traefik image\n    image: traefik:v2.2\n    ports:\n      # Listen on port 80, default for HTTP, necessary to redirect to HTTPS\n      - target: 80\n        published: 80\n        mode: host\n      # Listen on port 443, default for HTTPS\n      - target: 443\n        published: 443\n        mode: host\n    deploy:\n      placement:\n        constraints:\n          # Make the traefik service run only on the node with this label\n          # as the node with it has the volume for the certificates\n          - node.labels.traefik-public.traefik-public-certificates == true\n      labels:\n        # Enable Traefik for this service, to make it available in the public network\n        - traefik.enable=true\n        # Use the traefik-public network (declared below)\n        - traefik.docker.network=traefik-public\n        # Use the custom label \"traefik.constraint-label=traefik-public\"\n        # This public Traefik will only use services with this label\n        # That way you can add other internal Traefik instances per stack if needed\n        - traefik.constraint-label=traefik-public\n        # admin-auth middleware with HTTP Basic auth\n        # Using the environment variables USERNAME and HASHED_PASSWORD\n        - traefik.http.middlewares.admin-auth.basicauth.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n        # https-redirect middleware to redirect HTTP to HTTPS\n        # It can be re-used by other stacks in other Docker Compose files\n        - traefik.http.middlewares.https-redirect.redirectscheme.scheme=https\n        - traefik.http.middlewares.https-redirect.redirectscheme.permanent=true\n        # traefik-http set up only to use the middleware to redirect to https\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-http.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-http.entrypoints=http\n        - traefik.http.routers.traefik-public-http.middlewares=https-redirect\n        # traefik-https the actual router using HTTPS\n        # Uses the environment variable DOMAIN\n        - traefik.http.routers.traefik-public-https.rule=Host(`${DOMAIN?Variable not set}`)\n        - traefik.http.routers.traefik-public-https.entrypoints=https\n        - traefik.http.routers.traefik-public-https.tls=true\n        # Use the special Traefik service api@internal with the web UI/Dashboard\n        - traefik.http.routers.traefik-public-https.service=api@internal\n        # Use the \"le\" (Let's Encrypt) resolver created below\n        - traefik.http.routers.traefik-public-https.tls.certresolver=le\n        # Enable HTTP Basic auth, using the middleware created above\n        - traefik.http.routers.traefik-public-https.middlewares=admin-auth\n        # Define the port inside of the Docker service to use\n        - traefik.http.services.traefik-public.loadbalancer.server.port=8080\n    volumes:\n      # Add Docker as a mounted volume, so that Traefik can read the labels of other services\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      # Mount the volume to store the certificates\n      - traefik-public-certificates:/certificates\n    command:\n      # Enable Docker in Traefik, so that it reads labels from Docker services\n      - --providers.docker\n      # Add a constraint to only use services with the label \"traefik.constraint-label=traefik-public\"\n      - --providers.docker.constraints=Label(`traefik.constraint-label`, `traefik-public`)\n      # Do not expose all Docker services, only the ones explicitly exposed\n      - --providers.docker.exposedbydefault=false\n      # Enable Docker Swarm mode\n      - --providers.docker.swarmmode\n      # Create an entrypoint \"http\" listening on address 80\n      - --entrypoints.http.address=:80\n      # Create an entrypoint \"https\" listening on address 443\n      - --entrypoints.https.address=:443\n      # Create the certificate resolver \"le\" for Let's Encrypt, uses the environment variable EMAIL\n      - --certificatesresolvers.le.acme.email=${EMAIL?Variable not set}\n      # Store the Let's Encrypt certificates in the mounted volume\n      - --certificatesresolvers.le.acme.storage=/certificates/acme.json\n      # Use the TLS Challenge for Let's Encrypt\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # Enable the access log, with HTTP requests\n      - --accesslog\n      # Enable the Traefik log, for configurations and errors\n      - --log\n      # Enable the Dashboard and API\n      - --api\n    networks:\n      # Use the public network created to be shared between Traefik and\n      # any other service that needs to be publicly available with HTTPS\n      - traefik-public\n\nvolumes:\n  # Create a volume to store the certificates, there is a constraint to make sure\n  # Traefik is always deployed to the same Docker node with the same volume containing\n  # the HTTPS certificates\n  traefik-public-certificates:\n\nnetworks:\n  # Use the previously created public network \"traefik-public\", shared with other\n  # services that need to be publicly available via this Traefik\n  traefik-public:\n    external: true\n</code></pre> <p>And then deploying with:</p> <pre><code>docker stack deploy -c traefik-host.yml traefik\n</code></pre>"},{"location":"traefik/#distributed-lets-encrypt","title":"Distributed Let's Encrypt","text":"<p>There was a guide in DockerSwarm.rocks for setting up Traefik with Consul to store the Let's Encrypt certificates in a distributed way.</p> <p>Nevertheless, that technique was fragile and error prone. Because of that, the Traefik team disabled that functionality in Traefik version 2.</p> <p>In many cases the technique described here should be enough. But if you have a big and complex system that requires a distributed Let's Encrypt store for Traefik, you should check Traefik Enterprise Edition that supports it.</p>"},{"location":"traefik/#whats-next","title":"What's next","text":"<p>The next thing would be to deploy a stack (a complete web application, with backend, frontend, database, etc) using this Docker Swarm mode cluster.</p> <p>It's actually very simple, as you can use Docker Compose for local development and then use the same files for deployment in the Docker Swarm mode cluster.</p> <p>If you want to try it right now, you can check this project generator with a ReadyAPI backend and a frontend using Vue.js https://github.com/khulnasoft/full-stack-readyapi-postgresql.</p>"},{"location":"traefik-v1/","title":"Traefik v1","text":"<p>Here are the previous guides for Traefik using version 1.</p> <p>You can consider them obsolete, and you should probably use instead the most recent version at DockerSwarm.rocks/traefik/.</p> <p>But they are kept here for reference, in case you were using them and already have some stacks deployed with them.</p>"},{"location":"traefik-v1/traefik-technical-details/","title":"Traefik Proxy with HTTPS - Technical Details","text":""},{"location":"traefik-v1/traefik-technical-details/#note-about-traefik-v2","title":"Note about Traefik v2","text":"<p>This article is for Traefik version 1.</p> <p>There is now a guide for Traefik version 2, if you are starting a new project, you should check that one at DockerSwarm.rocks/traefik/.</p> <p>Warning</p> <p>The technique described here using Consul to store the Let's Encrypt certificates seemed to work well at first, but was fragile and error prone, and could lead to issues later. Because of that, the Traefik team disabled it in Traefik version 2.</p>"},{"location":"traefik-v1/traefik-technical-details/#consul","title":"Consul","text":"<p>Consul by default expects to be running independent of any cluster orchestrator. To have fixed IPs, etc.</p> <p>This configuration includes everything necessary to make it work in Docker Swarm, in a distributed and resilient manner.</p> <p>Consul expects to have a single leader at each time, and to have all the Consul instances communicating to each other, knowing each other's specific IP address/host.</p> <p>So, by default, you would have to make sure to set up a specific Consul instance per node in your cluster.</p> <p>And if your cluster has more nodes, or if one node goes down, you would have to manually create another Consul instance, etc.</p>"},{"location":"traefik-v1/traefik-technical-details/#consul-leader","title":"Consul leader","text":"<p>In this Docker Compose stack we define a single Consul leader named <code>consul-leader</code>, that is able to self-elect as a leader (<code>-boostrap</code>).</p> <p>There is also <code>consul-replica</code>, a service with multiple replicas. Each one of them will contact <code>consul-leader</code>, so, they will all end up exchanging their IP addresses and being able to synchronize (including the leader, once the replicas send him their data).</p> <p><code>consul-leader</code> is configured to listen to the first internal private IP address by using the environment variable <code>CONSUL_BIND_INTERFACE</code> listening on the first \"ethernet\" (virtual) interface <code>eth0</code>.</p> <p>It also has an evironment variable <code>CONSUL_LOCAL_CONFIG</code> with local configuration <code>{\"leave_on_terminate\": true}</code>. This means that if you re-deploy the service, the container it will leave the cluster before being turned off. And then the new container will be able to start. Otherwise, the new container will keep trying to contact the old container, without knowing that it is supposed to replace it.</p> <p>It is attached to the <code>default</code> network to be able to talk to the other <code>consul-replica</code> service (of multiple replica containers) and to the external network <code>traefik-public</code>, to be able to expose its web user interface with Traefik.</p> <p>It has several deployment labels, these are what make Traefik expose the Consul web UI with specific settings:</p> <ul> <li><code>traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}</code>: use as a host, the subdomain <code>consul</code> of the domain set in the environment variable <code>DOMAIN</code>. This host name is what will be used to genereate/acquire the HTTPS certificates. If there's no environment variable <code>DOMAIN</code>, show the error \"<code>Variable not set</code>\".</li> <li><code>traefik.enable=true</code>: tell Traefik to expose this service in the web (otherwise, it wouldn't).</li> <li><code>traefik.port=8500</code>: expose the content from the port <code>8500</code> (that's the port inside the container).</li> <li><code>traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}</code>: as the main Traefik proxy will only expose services with the <code>traefik-public</code> tag (using a parameter below), make the Consul service have this tag too, so that the Traefik public can find it and expose it. Use as the tag the environment variable <code>TRAEFIK_PUBLIC_TAG</code>, or by default, set it to <code>traefik-public</code>.</li> <li><code>traefik.docker.network=traefik-public</code>: tell Traefik to get the contents provided by this service using that shared network.</li> <li><code>traefik.frontend.entryPoints=http,https</code>: make the web UI listen and serve on HTTP and HTTPS.</li> <li><code>traefik.frontend.redirect.entryPoint=https</code>: make Traefik redirect HTTP trafic to HTTPS for the web UI.</li> <li><code>traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}</code>: enable basic auth, so that not everyone can access your Traefik web dashboard, it uses the username and password created above. If those environment variables are not set, show the error \"<code>Variable not set</code>\" or \"<code>Variable HASHED_PASSWORD not set</code>\".</li> </ul> <pre><code>version: '3.3'\n\nservices:\n  consul-leader:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap -ui\n    volumes:\n      - consul-data-leader:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8500\n        - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n  consul-replica:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=\"consul-leader\"\n    volumes:\n      - consul-data-replica:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      replicas: ${CONSUL_REPLICAS:-3}\n      placement:\n        preferences:\n          - spread: node.id\n  traefik:\n    image: traefik:v1.7\n    ports:\n      - 80:80\n      - 443:443\n    deploy:\n      replicas: ${TRAEFIK_REPLICAS:-3}\n      placement:\n        constraints:\n          - node.role == manager\n        preferences:\n          - spread: node.id\n      labels:\n        - traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8080\n        - traefik.tags=traefik-public\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --docker.watch\n      --docker.exposedbydefault=false\n      --constraints=tag==traefik-public\n      --entrypoints='Name:http Address::80'\n      --entrypoints='Name:https Address::443 TLS'\n      --consul\n      --consul.endpoint=\"consul-leader:8500\"\n      --acme\n      --acme.email=${EMAIL?Variable not set}\n      --acme.storage=\"traefik/acme/account\"\n      --acme.entryPoint=https\n      --acme.httpChallenge.entryPoint=http\n      --acme.onhostrule=true\n      --acme.acmelogging=true\n      --logLevel=INFO\n      --accessLog\n      --api\n    networks:\n      - default\n      - traefik-public\n    depends_on:\n      - consul-leader\n\nvolumes:\n  consul-data-leader:\n  consul-data-replica:\n\nnetworks:\n  traefik-public:\n    external: true\n</code></pre>"},{"location":"traefik-v1/traefik-technical-details/#consul-replicas","title":"Consul replicas","text":"<p><code>consul-replica</code> is a service with multiple replicas (multiple containers).</p> <p>Each of them will try to communicate and send their data to <code>consul-leader</code>, using <code>-retry-join=\"consul-leader\"</code>.</p> <p>By having them do that, and not forcing the leader to try to communicate with the replicas, you can set the replication of these <code>consul-replica</code>s to <code>0</code>, and the leader will still work alone, in case you have a single node.</p> <p>Then, if you have new nodes, you can set the variable again, and re-deploy. Docker Swarm mode will take care of making the deployed services consistent with the new state.</p> <p>It is set to distribute those replicas spread across the cluster with <code>spread: node.id</code>.</p> <p>It uses the environment variable <code>CONSUL_REPLICAS</code>, set by default to 3, to set the number of replicas.</p> <p>So, if you have a huge cluster and you want to have more Consul services, you can just update that environment variable, to a bigger number, right before deploying the stack.</p> <p>As each replica will send its data (IP, ID, etc) to the service <code>consul-leader</code>, that service will have all the IPs and IDs of the replicas, and then it will send their data to the rest.</p> <p>That way, all the Consul instances will be able to communicate and synchronize.</p> <pre><code>version: '3.3'\n\nservices:\n  consul-leader:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap -ui\n    volumes:\n      - consul-data-leader:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8500\n        - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n  consul-replica:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=\"consul-leader\"\n    volumes:\n      - consul-data-replica:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      replicas: ${CONSUL_REPLICAS:-3}\n      placement:\n        preferences:\n          - spread: node.id\n  traefik:\n    image: traefik:v1.7\n    ports:\n      - 80:80\n      - 443:443\n    deploy:\n      replicas: ${TRAEFIK_REPLICAS:-3}\n      placement:\n        constraints:\n          - node.role == manager\n        preferences:\n          - spread: node.id\n      labels:\n        - traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8080\n        - traefik.tags=traefik-public\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --docker.watch\n      --docker.exposedbydefault=false\n      --constraints=tag==traefik-public\n      --entrypoints='Name:http Address::80'\n      --entrypoints='Name:https Address::443 TLS'\n      --consul\n      --consul.endpoint=\"consul-leader:8500\"\n      --acme\n      --acme.email=${EMAIL?Variable not set}\n      --acme.storage=\"traefik/acme/account\"\n      --acme.entryPoint=https\n      --acme.httpChallenge.entryPoint=http\n      --acme.onhostrule=true\n      --acme.acmelogging=true\n      --logLevel=INFO\n      --accessLog\n      --api\n    networks:\n      - default\n      - traefik-public\n    depends_on:\n      - consul-leader\n\nvolumes:\n  consul-data-leader:\n  consul-data-replica:\n\nnetworks:\n  traefik-public:\n    external: true\n</code></pre>"},{"location":"traefik-v1/traefik-technical-details/#traefik","title":"Traefik","text":"<p>The <code>traefik</code> service exposes the ports <code>80</code> (standard for HTTP) and <code>443</code> (standard for HTTPS).</p> <p>It creates replicas set to the environment variable <code>TRAEFIK_REPLICAS</code>, or by default, <code>3</code>.</p> <p>It is marked to be started on Docker Swarm manager nodes, as it needs to be able to communicate to Docker directly, to be able to read the labels you create in the rest of the stacks.</p> <p>It has labels that configure how its own UI interface should be exposed (by himself), all the labels are very similar to the ones described above for Consul.</p> <p>Here are some specific details:</p> <ul> <li><code>traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}</code>: use as a host, the subdomain <code>traefik</code> of the domain set in the environment variable <code>DOMAIN</code>. This host name is what will be used to genereate/acquire the HTTPS certificates. If the environment variable <code>DOMAIN</code> is not set, show the error \"<code>Variable not set</code>\".</li> <li><code>traefik.port=8080</code>: the content of the Traefik web UI is served in the container port <code>8080</code>, this tells Traefik to get the content from this port when serving pages to the public (using the standard HTTPS port, <code>443</code>).</li> </ul> <p>The Traefik service is configured to communicate with Docker directly, using a mounted volume for <code>/var/run/docker.sock</code>. This is needed for it to be able to read the labels in the stacks you create later.</p> <p>The command has several flags:</p> <ul> <li><code>--docker</code>: enable Docker.</li> <li><code>--docker.swarmmode</code>: enable Docker Swarm Mode.</li> <li><code>--docker.watch</code>: enable \"watch\", so it reloads its config based on new stacks and labels.</li> <li><code>--docker.exposedbydefault=false</code>: don't expose all the services, only services with traefik.enable=true.</li> <li><code>--constraints=tag==traefik-public</code>: only show services with traefik.tag=traefik-public, to isolate from possible intra-stack traefik instances.</li> <li><code>--entrypoints='Name:http Address::80'</code>: create an entrypoint http, on port 80.</li> <li><code>--entrypoints='Name:https Address::443 TLS'</code>: create an entrypoint https, on port 443 with TLS enabled.</li> <li><code>--consul</code>: enable Consul to store configurations.</li> <li><code>--consul.endpoint=\"consul-leader:8500\"</code>: use the <code>consul-leader</code> host (the service in the same stack) with its domain to communicate with Consul.</li> <li><code>--acme</code>: enable Let's encrypt.</li> <li><code>--acme.email=${EMAIL?Variable not set}</code>: let's encrypt email, using the environment variable. If it is not set, show the error \"<code>Variable not set</code>\".</li> <li><code>--acme.storage=\"traefik/acme/account\"</code>: store the HTTPS certificates in this location in Consul.</li> <li><code>--acme.entryPoint=https</code>: the entrypoint for Let's encrypt - created above.</li> <li><code>--acme.httpChallenge.entryPoint=http</code>: use HTTP for the ACME (Let's Encrypt HTTPS certificates) challenge, as HTTPS was disabled after a security issue.</li> <li><code>--acme.onhostrule=true</code>: get new certificates automatically with host rules: \"traefik.frontend.rule=Host:web.example.com\".</li> <li><code>--acme.acmelogging=true</code>: log Let's encrypt activity - to debug when and if it gets certificates.</li> <li><code>--logLevel=INFO</code>: default logging, if the web UI is not enough to debug configurations and hosts detected, or you want to see more of the logs, set it to <code>DEBUG</code>. Have in mind that after some time it might affect performance.</li> <li><code>--accessLog</code>: enable the access log, to see and debug HTTP traffic.</li> <li><code>--api</code>: enable the API, which includes the dashboard.</li> </ul> <p>It is connected to the internal stack <code>default</code>, to store the configurations in Consul, and to <code>traefik-public</code>, to be able to communicate with other services in other stacks that are also attached to that network. That's how it can later serve the content from those services.</p> <p>Technically, Traefik and Consul could just use the network <code>traefik-public</code> to communicate, to store configurations, HTTPS certificates, etc. But it's more explicit what each network does having the intra-stack <code>default</code> network declared too.</p> <pre><code>version: '3.3'\n\nservices:\n  consul-leader:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap -ui\n    volumes:\n      - consul-data-leader:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8500\n        - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n  consul-replica:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=\"consul-leader\"\n    volumes:\n      - consul-data-replica:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      replicas: ${CONSUL_REPLICAS:-3}\n      placement:\n        preferences:\n          - spread: node.id\n  traefik:\n    image: traefik:v1.7\n    ports:\n      - 80:80\n      - 443:443\n    deploy:\n      replicas: ${TRAEFIK_REPLICAS:-3}\n      placement:\n        constraints:\n          - node.role == manager\n        preferences:\n          - spread: node.id\n      labels:\n        - traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8080\n        - traefik.tags=traefik-public\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --docker.watch\n      --docker.exposedbydefault=false\n      --constraints=tag==traefik-public\n      --entrypoints='Name:http Address::80'\n      --entrypoints='Name:https Address::443 TLS'\n      --consul\n      --consul.endpoint=\"consul-leader:8500\"\n      --acme\n      --acme.email=${EMAIL?Variable not set}\n      --acme.storage=\"traefik/acme/account\"\n      --acme.entryPoint=https\n      --acme.httpChallenge.entryPoint=http\n      --acme.onhostrule=true\n      --acme.acmelogging=true\n      --logLevel=INFO\n      --accessLog\n      --api\n    networks:\n      - default\n      - traefik-public\n    depends_on:\n      - consul-leader\n\nvolumes:\n  consul-data-leader:\n  consul-data-replica:\n\nnetworks:\n  traefik-public:\n    external: true\n</code></pre>"},{"location":"traefik-v1/traefik-with-volume/","title":"Traefik Proxy with HTTPS using volume","text":"<p>This article lives in:</p> <ul> <li>Medium</li> <li>GitHub</li> <li>DockerSwarm.rocks</li> </ul>"},{"location":"traefik-v1/traefik-with-volume/#note-about-traefik-v2","title":"Note about Traefik v2","text":"<p>This article is for Traefik version 1.</p> <p>There is now a guide for Traefik version 2, if you are starting a new project, you should check that one at DockerSwarm.rocks/traefik/.</p>"},{"location":"traefik-v1/traefik-with-volume/#set-up","title":"Set up","text":"<p>Set up a main load balancer with Traefik that handles the public connections and Let's encrypt HTTPS certificates.</p> <ul> <li>Connect via SSH to a manager node in your cluster (you might have only one node) that will have the Traefik service.</li> <li>Create a network that will be shared with Traefik and the containers that should be accessible from the outside, with:</li> </ul> <pre><code>docker network create --driver=overlay traefik-public\n</code></pre> <ul> <li>Create a volume in where Traefik will store HTTPS certificates:</li> </ul> <pre><code>docker volume create traefik-public-certificates\n</code></pre> <p>Note: you can store certificates in Consul and deploy Traefik in each node as a fully distributed load balancer, this guide covers deploying to a single node, with a mounted volume instead of a distributed Consul.</p> <ul> <li>Get the Swarm node ID of this node and store it in an environment variable:</li> </ul> <pre><code>export NODE_ID=$(docker info -f '{{.Swarm.NodeID}}')\n</code></pre> <ul> <li>Create a tag in this node, so that Traefik is always deployed to the same node and uses the existing volume:</li> </ul> <pre><code>docker node update --label-add traefik-public.traefik-public-certificates=true $NODE_ID\n</code></pre> <ul> <li>Create an environment variable with your email, to be used for the generation of Let's Encrypt certificates:</li> </ul> <pre><code>export EMAIL=admin@example.com\n</code></pre> <ul> <li>Create an environment variable with the name of the host, e.g.:</li> </ul> <pre><code>export USE_HOSTNAME=dog.example.com\n# or if you have your $HOSTNAME variable configured:\nexport USE_HOSTNAME=$HOSTNAME\n</code></pre> <ul> <li> <p>You will access the Traefik dashboard at <code>traefik.&lt;your hostname&gt;</code>, e.g. <code>traefik.dog.example.com</code>. So, make sure that your DNS records point <code>traefik.&lt;your hostname&gt;</code> to one of the IPs of the cluster. Better if it is the IP where the Traefik service runs (the manager node you are currently connected to).</p> </li> <li> <p>Create an environment variable with a username (you will use it for the HTTP Basic Auth), for example:</p> </li> </ul> <pre><code>export USERNAME=admin\n</code></pre> <ul> <li>Create an environment variable with the password, e.g.:</li> </ul> <pre><code>export PASSWORD=changethis\n</code></pre> <ul> <li>Use <code>openssl</code> to generate the \"hashed\" version of the password and store it in an environment variable:</li> </ul> <pre><code>export HASHED_PASSWORD=$(openssl passwd -apr1 $PASSWORD)\n</code></pre> <ul> <li>You can check the contents with:</li> </ul> <pre><code>echo $HASHED_PASSWORD\n</code></pre> <p>It will look like:</p> <pre><code>$apr1$89eqM5Ro$CxaFELthUKV21DpI3UTQO.\n</code></pre> <ul> <li>Create a Traefik service, copy this long command in the terminal:</li> </ul> <pre><code>docker service create \\\n    --name traefik \\\n    --constraint=node.labels.traefik-public.traefik-public-certificates==true \\\n    --publish 80:80 \\\n    --publish 443:443 \\\n    --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \\\n    --mount type=volume,source=traefik-public-certificates,target=/certificates \\\n    --network traefik-public \\\n    --label \"traefik.frontend.rule=Host:traefik.${USE_HOSTNAME?Variable not set}\" \\\n    --label \"traefik.enable=true\" \\\n    --label \"traefik.port=8080\" \\\n    --label \"traefik.tags=traefik-public\" \\\n    --label \"traefik.docker.network=traefik-public\" \\\n    --label \"traefik.frontend.entryPoints=http,https\" \\\n    --label \"traefik.frontend.redirect.entryPoint=https\" \\\n    --label \"traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\" \\\n    traefik:v1.7 \\\n    --docker \\\n    --docker.swarmmode \\\n    --docker.watch \\\n    --docker.exposedbydefault=false \\\n    --constraints=tag==traefik-public \\\n    --entrypoints='Name:http Address::80' \\\n    --entrypoints='Name:https Address::443 TLS' \\\n    --acme \\\n    --acme.email=${EMAIL?Variable not set} \\\n    --acme.storage=/certificates/acme.json \\\n    --acme.entryPoint=https \\\n    --acme.httpChallenge.entryPoint=http\\\n    --acme.onhostrule=true \\\n    --acme.acmelogging=true \\\n    --logLevel=INFO \\\n    --accessLog \\\n    --api\n</code></pre> <p>You will be able to securely access the web UI at <code>https://traefik.&lt;your domain&gt;</code> using the created username and password.</p> <p>The previous command explained:</p> <ul> <li><code>docker service create</code>: create a Docker Swarm mode service</li> <li><code>--name traefik</code>: name the service \"traefik\"</li> <li><code>--constraint=node.labels.traefik-public.traefik-public-certificates==true</code> make it run on a specific node, to be able to use the certificates stored in a volume in that node</li> <li><code>--publish 80:80</code>: listen on ports 80 - HTTP</li> <li><code>--publish 443:443</code>: listen on port 443 - HTTPS</li> <li><code>--mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock</code>: communicate with Docker, to read labels, etc.</li> <li><code>--mount type=volume,source=traefik-public-certificates,target=/certificates</code>: create a volume to store TLS certificates</li> <li><code>--network traefik-public</code>: listen to the specific network traefik-public</li> <li><code>--label \"traefik.frontend.rule=Host:traefik.${USE_HOSTNAME?Variable not set}\"</code>: enable the Traefik API and dashboard in the host <code>traefik.$USE_HOSTNAME</code>, using the <code>$USE_HOSTNAME</code> environment variable created above. If the variable is not set, show an error.</li> <li><code>--label \"traefik.enable=true\"</code>: make Traefik expose \"itself\" as a Docker service, this is what makes the Traefik dashboard available with HTTPS and basic auth</li> <li><code>--label \"traefik.port=8080\"</code>: when Traefik exposes itself as a service (for the dashboard), use the internal service port <code>8080</code></li> <li><code>--label \"traefik.tags=traefik-public\"</code>: as the main Traefik proxy will only expose services with the <code>traefik-public</code> tag (using a parameter below), make the dashboard service have this tag too, so that the Traefik public (itself) can find it and expose it</li> <li><code>--label \"traefik.docker.network=traefik-public\"</code>: make the dashboard service use the <code>traefik-public</code> network to expose itself</li> <li><code>--label \"traefik.frontend.entryPoints=http\"</code>: make the web dashboard listen and serve on HTTP and HTTPS</li> <li><code>--label \"traefik.frontend.redirect.entryPoint=https\"</code>: make Traefik redirect HTTP trafic to HTTPS for the web dashboard</li> <li><code>--label \"traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\"</code>: enable basic auth, so that not every one can access your Traefik web dashboard, it uses the username and password created above. If the variables are not set, show an error.</li> <li><code>traefik:v1.7</code>: use the image <code>traefik:v1.7</code></li> <li><code>--docker</code>: enable Docker</li> <li><code>--docker.swarmmode</code>: enable Docker Swarm Mode</li> <li><code>--docker.watch</code>: enable \"watch\", so it reloads its config based on new stacks and labels</li> <li><code>--docker.exposedbydefault=false</code>: don't expose all the services, only services with traefik.enable=true</li> <li><code>--constraints=tag==traefik-public</code>: only show services with traefik.tag=traefik-public, to isolate from possible intra-stack traefik instances</li> <li><code>--entrypoints='Name:http Address::80'</code>: create an entrypoint http, on port 80</li> <li><code>--entrypoints='Name:https Address::443 TLS'</code>: create an entrypoint https, on port 443 with TLS enabled</li> <li><code>--acme</code>: enable Let's encrypt</li> <li><code>--acme.email=${EMAIL?Variable not set}</code>: let's encrypt email, using the environment variable. If not set, show an error.</li> <li><code>--acme.storage=/certificates/acme.json</code>: where to store the Let's encrypt TLS certificates - in the mapped volume</li> <li><code>--acme.entryPoint=https</code>: the entrypoint for Let's encrypt - created above</li> <li><code>--acme.httpChallenge.entryPoint=http</code>: use HTTP for the ACME (Let's Encrypt HTTPS certificates) challenge, as HTTPS was disabled after a security issue</li> <li><code>--acme.onhostrule=true</code>: get new certificates automatically with host rules: \"traefik.frontend.rule=Host:web.example.com\"</li> <li><code>--acme.acmelogging=true</code>: log Let's encrypt activity - to debug when and if it gets certificates</li> <li><code>--logLevel=INFO</code>: default logging, if the web UI is not enough to debug configurations and hosts detected, or you want to see more of the logs, set it to <code>DEBUG</code>. Have in mind that after some time it might affect performance.</li> <li><code>--accessLog</code>: enable the access log, to see and debug HTTP traffic</li> <li><code>--api</code>: enable the API, which includes the dashboard</li> </ul>"},{"location":"traefik-v1/traefik-with-volume/#check-it","title":"Check it","text":"<p>To check if it worked, check the logs:</p> <pre><code>docker service logs traefik\n# To make it scrollable with `less`, run:\n# docker service logs traefik | less\n</code></pre> <p>And open <code>https://traefik.&lt;your domain&gt;</code> in your browser, you will be asked for the username and password that you set up before, and you will be able to see the Traefik web UI interface. Once you deploy a stack, you will be able to see it there and see how the different hosts and paths map to different Docker services / containers.</p>"},{"location":"traefik-v1/traefik-with-volume/#getting-the-client-ip","title":"Getting the client IP","text":"<p>If you need to read the client IP in your applications/stacks using the <code>X-Forwarded-For</code> or <code>X-Real-IP</code> headers provided by Traefik, you need to make Traefik listen directly, not through Docker Swarm mode, even while being deployed with Docker Swarm mode.</p> <p>For that, you need to publish the ports using \"host\" mode.</p> <p>So, the two lines above:</p> <pre><code>    --publish 80:80 \\\n    --publish 443:443 \\\n</code></pre> <p>need to be:</p> <pre><code>    --publish mode=host,target=80,published=80 \\\n    --publish mode=host,target=443,published=443 \\\n</code></pre> <p>Here's the complete command with those lines updated:</p> <pre><code>docker service create \\\n    --name traefik \\\n    --constraint=node.labels.traefik-public.traefik-public-certificates==true \\\n    --publish mode=host,target=80,published=80 \\\n    --publish mode=host,target=443,published=443 \\\n    --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \\\n    --mount type=volume,source=traefik-public-certificates,target=/certificates \\\n    --network traefik-public \\\n    --label \"traefik.frontend.rule=Host:traefik.${USE_HOSTNAME?Variable not set}\" \\\n    --label \"traefik.enable=true\" \\\n    --label \"traefik.port=8080\" \\\n    --label \"traefik.tags=traefik-public\" \\\n    --label \"traefik.docker.network=traefik-public\" \\\n    --label \"traefik.frontend.entryPoints=http,https\" \\\n    --label \"traefik.frontend.redirect.entryPoint=https\" \\\n    --label \"traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\" \\\n    traefik:v1.7 \\\n    --docker \\\n    --docker.swarmmode \\\n    --docker.watch \\\n    --docker.exposedbydefault=false \\\n    --constraints=tag==traefik-public \\\n    --entrypoints='Name:http Address::80' \\\n    --entrypoints='Name:https Address::443 TLS' \\\n    --acme \\\n    --acme.email=${EMAIL?Variable not set} \\\n    --acme.storage=/certificates/acme.json \\\n    --acme.entryPoint=https \\\n    --acme.httpChallenge.entryPoint=http\\\n    --acme.onhostrule=true \\\n    --acme.acmelogging=true \\\n    --logLevel=INFO \\\n    --accessLog \\\n    --api\n</code></pre>"},{"location":"traefik-v1/traefik-with-volume/#whats-next","title":"What's next","text":"<p>The next thing would be to deploy a stack (a complete web application, with backend, frontend, database, etc) using this Docker Swarm mode cluster.</p> <p>It's actually very simple, as you can use Docker Compose for local development and then use the same files for deployment in the Docker Swarm mode cluster.</p> <p>If you want to try it right now, you can check this very simple project generator with a minimal Flask backend and Vue.js frontend.</p>"},{"location":"traefik-v1/traefik/","title":"Traefik Proxy with HTTPS","text":"<p>This article lives in:</p> <ul> <li>Medium</li> <li>GitHub</li> <li>DockerSwarm.rocks</li> </ul>"},{"location":"traefik-v1/traefik/#note-about-traefik-v2","title":"Note about Traefik v2","text":"<p>This article is for Traefik version 1.</p> <p>There is now a guide for Traefik version 2, if you are starting a new project, you should check that one at DockerSwarm.rocks/traefik/.</p> <p>Warning</p> <p>The technique described here using Consul to store the Let's Encrypt certificates seemed to work well at first, but was fragile and error prone, and could lead to issues later. Because of that, the Traefik team disabled it in Traefik version 2.</p>"},{"location":"traefik-v1/traefik/#intro","title":"Intro","text":"<p>So, you have a Docker Swarm mode cluster set up as described in DockerSwarm.rocks.</p> <p>Now you can add a main, distributed, Traefik load balancer/proxy to:</p> <ul> <li>Handle connections.</li> <li>Expose specific services and applications based on their domain names.</li> <li>Handle multiple domains (if you need to). Similar to \"virtual hosts\".</li> <li>Handle HTTPS.</li> <li>Acquire (generate) HTTPS certificates automatically (including renewals) with Let's Encrypt.</li> <li>Add HTTP Basic Auth for any service that you need to protect and doesn't have its own security, etc.</li> <li>Get all its configurations automatically from Docker labels set in your stacks (you don't need to update configuration files).</li> </ul> <p>This article/guide covers setting up Traefik in a distributed system, including distributed HTTPS certificates.</p> <p>These ideas, techniques, and tools would also apply to other cluster orchestrators, like Kubernetes or Mesos, to add a main load balancer with HTTPS support, certificate generation, etc. But this article is focused on Docker Swarm mode.</p> <p>It's an alternative/continuation to a previous article Docker Swarm Mode and Traefik for an HTTPS cluster that covered Traefik in a Docker Swarm mode cluster but running on a single node.</p>"},{"location":"traefik-v1/traefik/#background","title":"Background","text":"<p>Docker Swarm mode with a main Traefik load balancer/proxy is the base cluster architecture that I'm using with my current team for most of the applications and projects.</p> <p>It's also used by several other friends and teams.</p>"},{"location":"traefik-v1/traefik/#overview","title":"Overview","text":"<p>This guide will show you how to set up Traefik as a load balancer/proxy and Consul to store configurations and HTTPS certificates.</p>"},{"location":"traefik-v1/traefik/#redundancy","title":"Redundancy","text":"<p>As Traefik and Consul are both distributed, it doesn't matter if one of your nodes/machines goes down, the distributed Traefik will be able to handle it from another of the nodes running, preserving HTTPS certificates, etc.</p> <p>So, you have \"redundancy\" in the load balancer in your cluster.</p> <p>You can easily have redundancy in your application using Docker Swarm.</p> <p>And if you set your domain name DNS records correctly, adding the IP addresses of several of the machines in your cluster, you would then have round-robin DNS load balancing for your application too.</p> <p>Full application redundancy.</p> <p>Note</p> <p>But if you have a single node, it will also work. And you can grow later if needed.</p>"},{"location":"traefik-v1/traefik/#user-interface","title":"User Interface","text":"<p>The guide includes how to expose the internal Traefik web UI through the same Traefik load balancer, using a secure HTTPS certificate and HTTP Basic Auth.</p> <p></p>"},{"location":"traefik-v1/traefik/#how-it-works","title":"How it works","text":"<p>The idea is to have a main load balancer/proxy that covers all the Docker Swarm cluster and handles HTTPS certificates and requests for each domain.</p> <p>But doing it in a way that allows you to have other Traefik services inside each stack without interfering with each other, to redirect based on path in the same stack (e.g. one container handles <code>/</code> for a web frontend and another handles <code>/api</code> for an API under the same domain), or to redirect from HTTP to HTTPS selectively.</p>"},{"location":"traefik-v1/traefik/#about-consul","title":"About Consul","text":"<p>Consul is a distributed configuration key/value store, it will:</p> <ul> <li>Store the Traefik configurations in a distributed manner.</li> <li>Make sure configurations are synchronized among Consul services across the cluster.</li> <li>Store HTTPS certificates for Traefik.</li> </ul>"},{"location":"traefik-v1/traefik/#preparation","title":"Preparation","text":"<ul> <li>Connect via SSH to a manager node in your cluster (you might have only one node) that will have the Traefik service.</li> <li>Create a network that will be shared with Traefik and the containers that should be accessible from the outside, with:</li> </ul> <pre><code>docker network create --driver=overlay traefik-public\n</code></pre> <ul> <li>Create an environment variable with your email, to be used for the generation of Let's Encrypt certificates:</li> </ul> <pre><code>export EMAIL=admin@example.com\n</code></pre> <ul> <li>Create an environment variable with the domain you want to use for the Traefik UI (user interface) and the Consul UI of the host, e.g.:</li> </ul> <pre><code>export DOMAIN=sys.example.com\n</code></pre> <p>You will access the Traefik UI at <code>traefik.&lt;your domain&gt;</code>, e.g. <code>traefik.sys.example.com</code> and the Consul UI at <code>consul.&lt;your domain&gt;</code>, e.g. <code>consul.sys.example.com</code>.</p> <p>So, make sure that your DNS records point <code>traefik.&lt;your domain&gt;</code> and <code>consul.&lt;your domain&gt;</code> to one of the IPs of the cluster.</p> <p>If you have several nodes (several IP addresses), you might want to create the DNS records for multiple of those IP addresses.</p> <p>That way, you would have redundancy even at the DNS level.</p> <ul> <li>Create an environment variable with a username (you will use it for the HTTP Basic Auth for Traefik and Consul UIs), for example:</li> </ul> <pre><code>export USERNAME=admin\n</code></pre> <ul> <li>Create an environment variable with the password, e.g.:</li> </ul> <pre><code>export PASSWORD=changethis\n</code></pre> <ul> <li>Use <code>openssl</code> to generate the \"hashed\" version of the password and store it in an environment variable:</li> </ul> <pre><code>export HASHED_PASSWORD=$(openssl passwd -apr1 $PASSWORD)\n</code></pre> <ul> <li>You can check the contents with:</li> </ul> <pre><code>echo $HASHED_PASSWORD\n</code></pre> <p>It will look like:</p> <pre><code>$apr1$89eqM5Ro$CxaFELthUKV21DpI3UTQO.\n</code></pre> <ul> <li>Create an environment variable with the number of replicas for the Consul service (if you don't set it, by default it will be 3):</li> </ul> <pre><code>export CONSUL_REPLICAS=3\n</code></pre> <p>If you have a single node, you can set <code>CONSUL_REPLICAS</code> to <code>0</code>, that way you will only have the Consul \"leader\", you don't need the replicas if you don't have other nodes yet:</p> <pre><code>export CONSUL_REPLICAS=0\n</code></pre> <p>Note: The Consul documentation says:</p> <p>It is expected that there be between three to five servers.</p> <p>So, you probably want to set <code>CONSUL_REPLICAS=3</code> or <code>CONSUL_REPLICAS=5</code>, but not more.</p> <ul> <li>Create an environment variable with the number of replicas for the Traefik service (if you don't set it, by default it will be 3):</li> </ul> <pre><code>export TRAEFIK_REPLICAS=3\n</code></pre> <p>...if you want to have one replica per node in your cluster, you can set it like this:</p> <pre><code>export TRAEFIK_REPLICAS=$(docker node ls -q | wc -l)\n</code></pre> <p>...if you have a single node, you can set <code>TRAEFIK_REPLICAS</code> to <code>1</code>:</p> <pre><code>export TRAEFIK_REPLICAS=1\n</code></pre>"},{"location":"traefik-v1/traefik/#create-the-docker-compose-file","title":"Create the Docker Compose file","text":"<ul> <li>Download the file <code>traefik-v1.yml</code>:</li> </ul> <pre><code>curl -L dockerswarm.khulnasoft.com/traefik-v1.yml -o traefik-v1.yml\n</code></pre> <ul> <li>...or create it manually, for example, using <code>nano</code>:</li> </ul> <pre><code>nano traefik-v1.yml\n</code></pre> <ul> <li>And copy the contents inside:</li> </ul> <pre><code>version: '3.3'\n\nservices:\n  consul-leader:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap -ui\n    volumes:\n      - consul-data-leader:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8500\n        - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n  consul-replica:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=\"consul-leader\"\n    volumes:\n      - consul-data-replica:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      replicas: ${CONSUL_REPLICAS:-3}\n      placement:\n        preferences:\n          - spread: node.id\n  traefik:\n    image: traefik:v1.7\n    ports:\n      - 80:80\n      - 443:443\n    deploy:\n      replicas: ${TRAEFIK_REPLICAS:-3}\n      placement:\n        constraints:\n          - node.role == manager\n        preferences:\n          - spread: node.id\n      labels:\n        - traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8080\n        - traefik.tags=traefik-public\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --docker.watch\n      --docker.exposedbydefault=false\n      --constraints=tag==traefik-public\n      --entrypoints='Name:http Address::80'\n      --entrypoints='Name:https Address::443 TLS'\n      --consul\n      --consul.endpoint=\"consul-leader:8500\"\n      --acme\n      --acme.email=${EMAIL?Variable not set}\n      --acme.storage=\"traefik/acme/account\"\n      --acme.entryPoint=https\n      --acme.httpChallenge.entryPoint=http\n      --acme.onhostrule=true\n      --acme.acmelogging=true\n      --logLevel=INFO\n      --accessLog\n      --api\n    networks:\n      - default\n      - traefik-public\n    depends_on:\n      - consul-leader\n\nvolumes:\n  consul-data-leader:\n  consul-data-replica:\n\nnetworks:\n  traefik-public:\n    external: true\n</code></pre> <p>Info</p> <p>This is just a standard Docker Compose file.</p> <p>It's common to name the file <code>docker-compose.yml</code> or something like <code>docker-compose.traefik.yml</code>.</p> <p>Here it's named just <code>traefik-v1.yml</code> for brevity.</p>"},{"location":"traefik-v1/traefik/#deploy-it","title":"Deploy it","text":"<p>Deploy the stack with:</p> <pre><code>docker stack deploy -c traefik-v1.yml traefik-consul\n</code></pre> <p>It will use the environment variables you created above.</p>"},{"location":"traefik-v1/traefik/#check-it","title":"Check it","text":"<ul> <li>Check if the stack was deployed with:</li> </ul> <pre><code>docker stack ps traefik-consul\n</code></pre> <p>It will output something like:</p> <pre><code>ID             NAME                              IMAGE           NODE                DESIRED STATE   CURRENT STATE          ERROR   PORT\nxvyasdfh56hg   traefik-consul_traefik.1          traefik:v1.7    dog.example.com     Running         Running 1 minute ago\nj3ahasdfe0mr   traefik-consul_consul-replica.1   consul:latest   cat.example.com     Running         Running 1 minute ago\nbfdasdfasr92   traefik-consul_consul-leader.1    consul:latest   cat.example.com     Running         Running 1 minute ago\nofvasdfqtsi6   traefik-consul_traefik.2          traefik:v1.7    snake.example.com   Running         Running 1 minute ago\ntybasdfqdutt   traefik-consul_consul-replica.2   consul:latest   dog.example.com     Running         Running 1 minute ago\n3ejasdfq2l3g   traefik-consul_traefik.3          traefik:v1.7    cat.example.com     Running         Running 1 minute ago\nw0oasdfqsv33   traefik-consul_consul-replica.3   consul:latest   snake.example.com   Running         Running 1 minute ago\n</code></pre> <ul> <li>You can check the Traefik logs with:</li> </ul> <pre><code>docker service logs traefik-consul_traefik\n</code></pre>"},{"location":"traefik-v1/traefik/#check-the-user-interfaces","title":"Check the user interfaces","text":"<p>After some seconds/minutes, Traefik will acquire the HTTPS certificates for the web user interfaces.</p> <p>You will be able to securely access the web UI at <code>https://traefik.&lt;your domain&gt;</code> using the created username and password.</p> <p>And the same way, to access the Consul web user interface at <code>https://consul.&lt;your domain&gt;</code>.</p>"},{"location":"traefik-v1/traefik/#updating","title":"Updating","text":"<p>Let's say you add a couple of new nodes to your cluster, and you want to increment the number of Consul replicas or Traefik replicas.</p> <p>You can just set the environment variables again, and re-deploy. Docker Swarm mode will take care of making sure the state of the system is consistent.</p>"},{"location":"traefik-v1/traefik/#getting-the-client-ip","title":"Getting the client IP","text":"<p>If you need to read the client IP in your applications/stacks using the <code>X-Forwarded-For</code> or <code>X-Real-IP</code> headers provided by Traefik, you need to make Traefik listen directly, not through Docker Swarm mode, even while being deployed with Docker Swarm mode.</p> <p>For that, you need to publish the ports using \"host\" mode.</p> <p>So, the Docker Compose lines:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n</code></pre> <p>need to be:</p> <pre><code>    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n</code></pre> <p>You can use all the same instructions above, downloading the host-mode file:</p> <pre><code>curl -L dockerswarm.khulnasoft.com/traefik-host.yml -o traefik-host.yml\n</code></pre> <p>Or alternatively, copying it directly:</p> <pre><code>version: '3.3'\n\nservices:\n  consul-leader:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap -ui\n    volumes:\n      - consul-data-leader:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      labels:\n        - traefik.frontend.rule=Host:consul.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8500\n        - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n  consul-replica:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=\"consul-leader\"\n    volumes:\n      - consul-data-replica:/consul/data\n    environment:\n      - CONSUL_BIND_INTERFACE=eth0\n      - 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true}'\n    networks:\n      - default\n      - traefik-public\n    deploy:\n      replicas: ${CONSUL_REPLICAS:-3}\n      placement:\n        preferences:\n          - spread: node.id\n  traefik:\n    image: traefik:v1.7\n    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n    deploy:\n      replicas: ${TRAEFIK_REPLICAS:-3}\n      placement:\n        constraints:\n          - node.role == manager\n        preferences:\n          - spread: node.id\n      labels:\n        - traefik.frontend.rule=Host:traefik.${DOMAIN?Variable not set}\n        - traefik.enable=true\n        - traefik.port=8080\n        - traefik.tags=traefik-public\n        - traefik.docker.network=traefik-public\n        - traefik.frontend.entryPoints=http,https\n        - traefik.frontend.redirect.entryPoint=https\n        - traefik.frontend.auth.basic.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --docker.watch\n      --docker.exposedbydefault=false\n      --constraints=tag==traefik-public\n      --entrypoints='Name:http Address::80'\n      --entrypoints='Name:https Address::443 TLS'\n      --consul\n      --consul.endpoint=\"consul-leader:8500\"\n      --acme\n      --acme.email=${EMAIL?Variable not set}\n      --acme.storage=\"traefik/acme/account\"\n      --acme.entryPoint=https\n      --acme.httpChallenge.entryPoint=http\n      --acme.onhostrule=true\n      --acme.acmelogging=true\n      --logLevel=INFO\n      --accessLog\n      --api\n    networks:\n      - default\n      - traefik-public\n    depends_on:\n      - consul-leader\n\nvolumes:\n  consul-data-leader:\n  consul-data-replica:\n\nnetworks:\n  traefik-public:\n    external: true\n</code></pre> <p>And then deploying with:</p> <pre><code>docker stack deploy -c traefik-host.yml traefik-consul\n</code></pre>"},{"location":"traefik-v1/traefik/#whats-next","title":"What's next","text":"<p>The next thing would be to deploy a stack (a complete web application, with backend, frontend, database, etc) using this Docker Swarm mode cluster.</p> <p>It's actually very simple, as you can use Docker Compose for local development and then use the same files for deployment in the Docker Swarm mode cluster.</p> <p>If you want to try it right now, you can check this very simple project generator with a minimal Flask backend and Vue.js frontend.</p> <p>It has everything set up to be deployed in a Docker Swarm mode cluster with Traefik as described in this article.</p>"},{"location":"traefik-v1/traefik/#technical-details","title":"Technical Details","text":"<p>If you want to see the technical details of what each part of the Docker Compose <code>traefik-v1.yml</code> file do, check the chapter \"Traefik Proxy with HTTPS - Technical Details\".</p>"}]}